<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AutoMapper.Extensions.Microsoft.DependencyInjection - AddAutoMapper 已過時]]></title>
    <url>%2F2019%2FAutoMapper-Extensions-Microsoft-DependencyInjection-AddAutoMapper-%E5%B7%B2%E9%81%8E%E6%99%82%2F</url>
    <content type="text"><![CDATA[AutoMapper.Extensions.Microsoft.DependencyInjection 簡單的讓 AutoMapper 註冊到 ASP.NET Core 中，但更版之後出現以 AddAutoMapper() 已過期的訊息，紀錄一下新版的用法。 舊版用法1services.AddAutoMapper(); AddAutoMapper() 會掃描所有 assembliy 然後做兩件事： 將實作 IProfile 的類別加入 mapping configuration 將 value resolvers, member value resolvers, type converters 加入 container 更新套件後出現1ServiceCollectionExtensions.AddAutoMapper(IServiceCollection)&apos; is obsolete 原因新版本異動了參數簽章 改為傳入 assemblies 1services.AddAutoMapper(assembly1, assembly2 /*, ...*/); 或傳入 types 1services.AddAutoMapper(type1, type2 /*, ...*/); 解決方法 不怕麻煩的一個個傳入 改用以下寫法，仍然可以自動全部掃描 單一專案：傳入 Starup.cs1services.AddAutoMapper(typeof(Startup)); 多個專案參考：傳入 所有 Assemblies1services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); 參考連結https://github.com/AutoMapper/AutoMapper.Extensions.Microsoft.DependencyInjection/issues/105]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>C#</tag>
        <tag>AutoMapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩玩樹莓派 - 序篇]]></title>
    <url>%2F2019%2F%E7%8E%A9%E7%8E%A9%E6%A8%B9%E6%A2%85%E6%B4%BE-%E5%BA%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[樹莓派是個微型電腦，藉由低成本高效能的硬體，讓更多人可以踏進電腦學習的世界，而至今，樹莓派上可以安裝很多種系統，做許多特定的事情，本文就是一系列的教學安裝心得。 預計有以下主題 智能家居：Hass.io 懷舊遊戲機：Retro Pie 懷舊遊戲機：Recalbox]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jeykll 快速安裝教學]]></title>
    <url>%2F2019%2FJeykll-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[Jeykll 是 Github 的聯合創始人的作品，以 Ruby 開發的靜態網頁產生器，是目前最受歡迎的，相關資源最多的 ssg，本篇就來簡單快速教學。 安裝先安裝 Ruby Windows 可以參考安裝 RudyInstaller for Windows 更新 Rudy Gems 1gem update --system 安裝 Jekyll 1gem install bundler jekyll 第一個站台1jekyll new jekylldemo 12cd jekylldemobundle exec jekyll serve 部署Github Pages 是和 Jekyll 最合拍的 Hosting 空間，同個一爸爸的優勢下，只要將整個原始檔案簽入 Github，過一會就會自動生成檔案。 結論優點 和 Github Pages 深度整合（其他 Hosting 空間也是很容易部署）。 相關插件資源眾多。 _config.yml 設定統一。 缺點 操作指令較少（搭配 rake 會好很多）。 產生靜態頁速度較慢。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hugo 快速安裝教學]]></title>
    <url>%2F2019%2FHugo-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[Hugo 是用 Go 語言開發的靜態網站產生器（Static Site Generator），有著超快產生速度的優點，就讓我們來玩玩看吧。 安裝Hugo 提供多種安裝方式，含括 Windows / Linux / macOS，以下列出 Windows 與 macOS 安裝方式，其他安裝方式請直接參考官網說明。 Chocolatey (Windows)1choco install hugo -confirm Homebrew (macOS)1brew install hugo 其他安裝方式請參考 install。 檢查安裝版本1hugo version 建立新站台1hugo new site hugodemo 新增佈景主題Hugo 安裝好是沒有佈景主題的，所以接下來必須來設定佈景主題。 相較於 Hugo，Hexo、Jekyll有預設佈景主題，這點是 Hugo 較為不便的地方。 下載佈景主題使用 git 下載，好處是新版本更新很方便。 123cd hugodemogit initgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 若沒有 git 的環境，可以直接下載 ananke theme 解壓縮放入 hugodemo/themes/ananke。 編輯 config.toml 並將主題設定為 Ananke1echo theme = "ananke" &gt;&gt; config.toml 其他佈景主題Hugo 也提供了很多佈景主題，請直接參考 Hugo Themes。 增加一個新文章1hugo new posts/my-first-post.md 啟動站台1hugo server -D 在瀏覽器中輸入紅框處網址即可看成果了。 Hugo 預設 port 為 1313，若被佔用會置換成其他 port。 目錄說明若展開 hugodemo 資料夾，會包含以下內容.├── archetypes│ └── default.md├── config.toml├── content├── data├── layouts├── static└── themes 其中 archetypes: 放置生成文件的基礎樣板資料夾。config.toml: 控制 hugo 產生網頁內容的設定檔，預設使用 toml 格式。（也支援 yaml 與 json 格式）。content: 放置 Markdown 文章與網頁內容的資料夾。data: 儲存一些 configuration 檔案的地方，協助建構靜態網頁。layouts: 儲存產生的網頁 layout 樣板（之後範例使用其他的 theme）。static: 放置靜態內容，如圖片，CSS 以及 *.js 等內容。themes: 從外部引入的 theme 檔案。 目前只要知道 config.toml, content, static 與 themes 這幾個部分即可。 站台設定打開 config.toml 1234baseURL = "https://example.org/"languageCode = "en-us"title = "My New Hugo Site"theme = "ananke" 部署當成功的執行站台後，產生的靜態檔會生成在 public 的資料夾下，將此資料夾的靜態檔部署到 Hosting 主機上。 各平台部署方式請參考官網說明。 結論優點 快！快！快！ 已整合眾多功能（分類、標籤、Sitemap、GA）。 config.toml 設定統一。 缺點 提供的佈景主題較少。 擴充插件較少。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩玩樹莓派 - RetroPie]]></title>
    <url>%2F2019%2F%E7%8E%A9%E7%8E%A9%E6%A8%B9%E8%8E%93%E6%B4%BE-RetroPie%2F</url>
    <content type="text"><![CDATA[Retro-Pie，復古的、樹梅派。RetroPie 是英國的一個開源專案，內建了許多經典遊戲的模擬器：GBA、N64、PSX 等等，而最近 Steam 官方釋出 Raspberry Pi 可以用的 Steam Link，RetroPie 也把它包進套件裡面。所以現在裝好 RetroPie 後，不只可以玩經典的神奇寶貝、牧場物語、馬力歐賽車，更可以玩 GTA V、Overcooked! 2。（當然前提你要有這些老遊戲的 ROM、也要有 Steam 遊戲） RetroPie 其實是基於 Raspbian 系統的一些套件，如果你已經有一台服役中的 Raspberry Pi，也可以直接安裝 RetroPie 的套件，不過還是建議跟著下面的步驟走，安裝預先做好的 RetroPie 映像檔（pre-build image），因為我已經幫你把一些雷踩過了。]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>Retro Pie</tag>
        <tag>懷舊遊戲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩玩樹莓派 - Hass.io]]></title>
    <url>%2F2019%2F%E7%8E%A9%E7%8E%A9%E6%A8%B9%E8%8E%93%E6%B4%BE-Hass-io%2F</url>
    <content type="text"><![CDATA[Hass.io 是 Home Assistant （簡稱 HA） 的 container 版本，HA 主流安裝有兩種方式, 是 Hassbian 與 Hassio; 但其實 HA 官方目前主推 Hass.io，優點是其有著友善的圖形介面、技術要求低, 對新手友善, 整體來說相對簡單，Hassio裡有類似 Plugin Store 的設計，擴充插件較為方便。 事前準備硬體 Raspberry Pi 3 model B+ 16G 以上的 micro SD 卡（官方建議 32G 以上） 5v 2.5A電源線（建議要足瓦） 軟體 Hass.io images Etcher 安裝燒進記憶卡開機安裝]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>Hass.io</tag>
        <tag>Home Assistant</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靜態網站產生器大比拚]]></title>
    <url>%2F2019%2FStatic-Site-Generator-Comparison%2F</url>
    <content type="text"><![CDATA[靜態網站產生器 (Static Site Generator) 是快速架站的利器，更是輕量級部落格架站的好幫手，本篇將常見的 Jekyll、Hexo、Hugo 三套工具做了評比‧。 選擇靜態網站的原因？現在有很多網站後端程式語言可供選擇，為什麼許多網站仍選擇靜態網站？ 不需要 Database。 不需要後端程式。 要速度快 靜態網站與動態網站相比更快，因為它們不需要後端處理或 Database 處理。 要安全性高 靜態網站比任何動態網站都更安全，因為安全漏洞更少。 Cache 靜態頁較容易且有效率。 JekyllJekyll是基於 Ruby Gem 的解析引擎，能夠將樣板、liquid 語言、markdown 轉換為”靜態網頁”的產生器。 Jekyll 優點 免費和開源。 簡單易用。 輕鬆地從熱門平台（例如WordPress）遷移內容。 Github Pages 支援。 自帶默認主題，安裝後即可使用。 眾多的插件。 完整的教學文件。 Jekyll 缺點 隨著網站內容的增長，構建過程變得非常慢。 很多插件都過時了。 HugoHugo 是一個用 Go 構建的靜態網站生成器。它被宣傳為“世界上最快的網站構建框架”。與Jekyll不同，Hugo是用Go編寫的，這是一種靜態編譯的語言。這在很多方面影響了 Hugo 的功能特別是插件。 可以在幾秒鐘內安裝Hugo，並在不到一秒的時間內構建一個平均靜態網站。 Hugo 優點 開源和免費。 超快的速度，引擎和速度優化。 Hugo 缺點 主題使用 Go 模板，需要熟悉 Go 來創建主題 Hugo 沒有附帶默認主題。 插件較少。 HexoHexo是基於 Node.js 的靜態網站生成器，Hexo 可以在幾秒鐘內生成數百個靜態文件。 優點 開源和免費。 自帶默認主題，安裝後即可使用。 速度快 Node.js 帶給您超級快的檔案產生速度，上百個檔案只需幾秒就能建立完成。 一鍵部署 強大的Markdown支持 Hexo 支援所有 GitHub Flavored Markdown 的功能，您甚至能在 Hexo 使用大部份的 Octopress 外掛。 豐富的外掛 Hexo 有強大的外掛系統，您可安裝外掛讓 Hexo 支援 Jade, CoffeeScript。 缺點 Hexo 有一個相對較大的社區，但大多數是非英語人士（來自中國） 錯綜複雜的 npm 生態 人氣大比拚 來源出處 結論最後選擇了 Hexo 作為 Blog 生成器，原因有幾個 中文資源多 插件功能齊全完整 node.js 較為熟悉 你，選擇哪個呢？]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
        <tag>Hugo</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB Sharding with Docker]]></title>
    <url>%2F2019%2FMongoDB-Sharding-with-Docker%2F</url>
    <content type="text"><![CDATA[sharding 為 MongoDB 所擁有的一種資料分散處理架構，簡單的說就是將資料分片 (shard) 儲存到不同的機器中，最常應用在大數據的案例上。在海量資料的儲存情境上，垂直擴充架構是無法滿足的，必須透過水平擴充來實現。 基本觀念基本角色MongoDB 的 sharding 有三種角色 shard：負責存放資料，3.6 版後須為 replica set 架構 config servers：負責記錄資料存在那些 shard 中，3.6 版後須為 replica set 架構 mongos：擔任 router 功能，接收 clitent application 的請求，向 config servers 查詢資料所在的 shard（會快取），然後去 shard 拿取資料 replica setMongoDB 服務器集群，用於實現 Relication 和 Automatic failover。 Relication 策略有兩種： one primary and two secondary一個 primary node + 二個 secondary node，優點是二份備份，適合需要資料高度安全的情境。 one primary, one secondary and one arbiter一個 primary node + 一個 secondary node + 一個 arbiter，arbiter 不存放資料，只負責 heartbeat，優點是節省資料保存空間，適合硬碟空間有限的情境。 動手實作container 規劃說明在 docker 環境下，快速建立起 mongodb sharding 架構規劃，在空間有限下我們用 3 台 mongos、3 台 config servers、2 個 shard（採用 one primary, one secondary and one arbiter，所以有 2 台 primary、2 台 secondary、2 台 arbiter 共 6 台） container 清單： shard：shard1-data1shard1-data2shard1-arbitershard2-data1shard2-data2shard2-arbiter config servers：config1config2config3 mongos：mongos1mongos2mongos3 產生 keyfile keyfile 適合在開發或測試環境中使用，正式環境建議使用 x.509 certificates 使用 keyfile 身份驗證，replica set 中的每個 mongod 都使用 keyfile 的內容作為共享密碼來驗證部署中的其他成員。只有具有正確 keyfile 的 mongod 才能加入 replica set。 在 UNIX 系統上，密鑰文件不得具有 group 或 world 權限。 在 Windows 系統上，不檢查密鑰文件權限。 12openssl rand -base64 756 &gt; &lt;path-to-keyfile&gt;chmod 400 &lt;path-to-keyfile&gt; 產生好的 keyfile 名稱為 路徑為 ```c:\data\mongo\```12345678910### 建立 volume```shdocker volume create mongo-shard1-data1docker volume create mongo-shard1-data2docker volume create mongo-shard1-arbdocker volume create mongo-shard2-data1docker volume create mongo-shard2-data2docker volume create mongo-shard2-arb 建立 shard1234567891011121314# 建立 shard1-data1docker run -v c:/data/mongo/mongo-keyfile:/data/mongo-keyfile --name shard1-data1 --net host --restart always -d -v c:/data/mongo/shard1-data1:/data/db mongo mongod --shardsvr --replSet shard1 --port 27018 --auth --keyFile /data/mongo-keyfile --bind_ip localhost# 建立 shard1-data2docker run -v c:/data/mongo/mongo-keyfile:/data/mongo-keyfile --name shard1-data2 --net host --restart always -d -v c:/data/mongo/shard1-data2:/data/db mongo mongod --shardsvr --replSet shard1 --port 27019 --auth --keyFile /data/mongo-keyfile --bind_ip localhost# 建立 shard1-arbiterdocker run -v c:/data/mongo/mongo-keyfile:/data/mongo-keyfile --name shard1-arbiter --net host --restart always -d -v c:/data/mongo/shard1-arbiter:/data/arbiter mongo /bin/bash -c " mkdir -p /data/arbiter | mongod --replSet shard1 --dbpath /data/arbiter --port 27020 --auth --keyFile /data/mongo-keyfile --bind_ip localhost"docker run -p 27018:27018 --name mongo-shard1-data1 --restart always -d -v mongo-shard1-data1:/data/db mongo mongod --shardsvr --replSet shard1 --port 27018 --bind_ip localhostdocker run -p 27019:27019 --name mongo-shard1-data2 --restart always -d -v mongo-shard1-data2:/data/db mongo mongod --shardsvr --replSet shard1 --port 27019 -- --bind_ip localhostdocker run -p 27020:27020 --name mongo-shard1-arb --restart always -d -v mongo-shard1-arb:/data/arb mongo /bin/bash -c " chmod 777 /data/arb | mongod --replSet shard1 --dbpath /data/arb --port 27020 --bind_ip localhost" mongos –configdb config-set/srvmongoDB3:47018,srvmongoDB2:47019,srvmongoDB1:47020 –bind_ip localhost,srvmongoDB3 –port 37018 –keyFile /data/mongo-keyfile 設定 shard1123456789101112131415161718192021222324252627282930313233343536373839docker exec -it mongo-shard1-data1 mongo localhost:27018use admindb.createUser( &#123; user: "admin", pwd: "admin", roles: [ &#123; role: "root", db: "admin" &#125; ] &#125;);config = &#123; "_id": "shard1", "members": [ &#123; _id:0,host:"localhost:27018" &#125;, &#123; _id:1,host:"localhost:27019" &#125;, &#123; _id:2, host:"localhost:27020", arbiterOnly:true &#125;] &#125;rs.initiate(config)rs.status()rs.initiate()rs.status();db.auth("admin","admin");rs.add("localhost:27019")rs.addArb("localhost:27020")rs.status(); 建立 config servers建立 mongos]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 LINQ 處理分群情境]]></title>
    <url>%2F2018%2F%E7%94%A8%20LINQ%20%E8%99%95%E7%90%86%E5%88%86%E7%BE%A4%E6%83%85%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Language Integrated Query (LINQ) 是一組以直接將查詢功能整合至 C# 語言為基礎之技術的名稱。LINQ 最明顯的「語言整合」部分就是查詢運算式。 查詢運算式是以宣告式「查詢語法」撰寫。 透過使用查詢語法，您就可以利用最少的程式碼，針對資料來源執行篩選、排序及分組作業。(參考來源) LINQ的強大不是本文的重點，本文主要是示範如何簡潔的處理資料分群問題。 情境說明一組數量不固定的數字集合，想平均分配至30組中。 土法煉鋼法最簡單的方式可以用一個 for 迴圈快速解決，但這實在太不優雅了。 LINQ 解法LINQ 可以很優雅地解決這個問題。 1234567891011121314151617var ids = new List&lt;int&gt;() &#123; 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87,&#125;;var result = ids.Select((value, index) =&gt; new &#123; PairNum = index % 30, value &#125;) .GroupBy(pair =&gt; pair.PairNum) .Select(grp =&gt; grp.Select(g =&gt; g.value).ToList()) .ToList();result.Dump(); 分群結果 範例程式Github範例]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>LINQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit 空資料夾]]></title>
    <url>%2F2018%2F%E5%9C%A8-Git-Commit-%E7%A9%BA%E8%B3%87%E6%96%99%E5%A4%BE%2F</url>
    <content type="text"><![CDATA[Git 基本只對檔案作版控，資料夾中若沒有檔案是無法 commit 的，若想要 commit 空資料夾才可採取下面兩種做法。 新增 .gitkeep / .keep 在目的空資料夾開啟 Git Bash，執行以下命令，產生空檔案 1touch .gitkeep 檔案名稱其實隨意都可，但 .gitkeep / .keep 較常見。 新增 .gitingore 在目的空資夾下新增一個 .gitingore 檔案並編輯如下 1234# 忽略所有文件*# 除了這個文件!.gitignore 我個人是比較喜歡第一種作法，讓 .gitingore 還是總控在根目錄下。]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（5）－Material 主題設定]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-5-Material-%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[自建 Blog 其中一種樂趣就是可以換很多種風格迥異的主題，不過仍需要一點程式基礎才能做好設定，接下來會以 Hexo 排名第二的主題 - Material 來做說明。 下載主題與更名設定檔Hexo 只需要將主題文件放置於站點目錄的 themes 目錄下。從 Github 下載最新版本。並更名為 material。 資料夾可任意更名，但 _config.yml 的設定需同資料夾名稱。 第一次啟用時需先將 material 內的 _config.template.yml 更名為 _config.yml。 如何變更主題先理解兩個名詞 站點配置文件 站點目錄下的 _config.yml 主題配置文件 material 資料夾下的 _config.yml 開啟站點配置文件，更改 language 與 theme 設定 語系支援清單 العَرَبِيَّة (ar) Deutsch (de) English (en) Español (es) Français (fr) 日本語 (ja) Malay (ms) Portuguese (Brazil) (pt-BR) 简体中文 (zh-CN) 繁體中文 (zh-TW) 1language: zh-TW 1theme: material 為什麼選擇 Material 真的很潮，Material Design 真的很潮，讓人印象深刻。 完整的文件說明，說明連結 整合眾多功能，整合了回覆留言、標籤、分類、時間軸、站內搜尋、 QR Code 等功能 Material 主題設定接下來主題配置文件的設定 設定樣式 Paradox: 標準 Material Design Isolation: 極簡風格 Nexus: 未完成，此專案已經久未更新，應該是沒有完成之日了。 1234# Schemesscheme: Paradox#scheme: Isolation#scheme: Nexus 選單設定 選單設定是比較有趣的地方，可以自由排列想要選單。 icon: 使用 Material icon，完整 icon 清單請參考 material design icons divider: 分隔線 12345678910111213141516171819202122232425262728293031323334353637383940414243# Sidebar Customizesidebar: dropdown: Email Me: link: mail@mail.com icon: email Github: link: "https://github.com/username" icon: layers homepage: use: true icon: home divider: false archives: use: true icon: inbox divider: false categories: use: true icon: chrome_reader_mode divider: false pages: 標籤: link: "/tags" icon: bookmark divider: false 時間軸: link: "/timeline" icon: timeline divider: false #About: #link: "/about" #icon: person #divider: false article_num: use: true divider: false footer: divider: true theme: true support: false feedback: false material: false 如此就一個看起來蠻完整的外觀囉。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
        <tag>Hexo Themes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo（4）－部署到 GitHub Pages]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-4-%E9%83%A8%E7%BD%B2%E5%88%B0-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[Hexo 產生的靜態網誌預設可以本機執行，但若要讓大家看看到勢必要部署到外部網路空間，由於是靜態網站部署到哪個網頁空間都不成問題，本文是建議部署到 GitHub Pages 上，以下就一步步說明步驟。 部署說明Hexo 預設可以支援以下部署方式 Git Heroku Rsync OpenShift FTPSync SFTP 手動 Copy public 資料夾 本文使用 Git 部署，需先安裝 hexo-deployer-git 套件 其他部署方式請參考 Hexo部署 1npm install hexo-deployer-git --save GitHub Pages 設定到 GitHub 上新增一個 repo，名稱必須是 {username}.github.io 設定 _config.yml1234deploy: type: git repo: https://&lt;username&gt;:&lt;password&gt;@github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master repo 有幾種驗證方式可以 push 到 Github，這裡選擇最簡單的自帶帳密的方式。 若有多組 Git 部署可以參考以下設定 12345deploy: type: git repo: github: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git,master gitcafe: https://gitcafe.com/&lt;username&gt;/&lt;username&gt;.git,gitcafe-pages 若是多種部署方式可參考以下設定 12345deployer:– type: git repo:– type: heroku repo: 開始部署請執行以下命令 1hexo d 也可使用以下兩種指定，產生網頁後部署 1hexo d -g 或 1hexo g -d 執行完之後就算完成部署到外部網頁空間囉。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 ASP.NET Core 中使用 AutoMapper]]></title>
    <url>%2F2018%2F%E5%9C%A8-ASP-NET-Core-%E4%B8%AD%E4%BD%BF%E7%94%A8-AutoMapper%2F</url>
    <content type="text"><![CDATA[AutoMapper 是一個類別對應轉換的套件，在ASP.NET Core專案中的用法有有點差異，本篇說明適合ASP.NET Core 的簡潔用法。 安裝套件1Install-Package AutoMapper.Extensions.Microsoft.DependencyInjection 此套件是使用 ASP.Net Core 自帶的 DI Framework，讓 AutoMapper 使用上更簡潔優雅，此套件依賴了 AutoMapper，會自動安裝。 加入 Startup.cs123456public void ConfigureServices(IServiceCollection services)&#123; // 加入 AutoMapper services.AddAutoMapper(); services.AddMvc();&#125; ASP.Net Core 專案中要使用什麼東西皆是相同套路，在 ConfigureServices 中 AddAutoMapper 這個 Middleware。 建立 Profile12345678public class UserProfie : Profile&#123; public UserProfie() &#123; // 建立 Profile 對照定義 CreateMap&lt;UserResultModel, UserViewModel&gt;(); &#125;&#125; Profile 的重點在繼承 Profile 這個類別 使用 IMapper1234567891011121314151617181920212223public class HomeController : Controller&#123; private IMapper _mapper; private IUserService _userService; public HomeController(IMapper mapper, IUserService userService) &#123; this._mapper = mapper; this._userService = userService; &#125; public IActionResult Index() &#123; // 取得 user var user = this._userService.Get(); // 將 user 置換成 ViewModel var userViewModel = _mapper.Map&lt;IEnumerable&lt;UserViewModel&gt;&gt;(user); ViewData["User"] = userViewModel; return View(); &#125;&#125; 只要透過建構式注入 IMapper，就可以透過 Map 這個方法 Mapper Profile 有定義到類別。 結論這樣的作法有什麼好處呢？ 夠簡潔。使用 AddAutoMapper 方法，啟動 AutoMapper middleware，簡單明瞭。 低耦合。藉由繼承 Profile ，AutoMapper 自動取得所有定義 Profile，並將 IMapper 注入到需要的區塊中，降低程式碼對 AutoMapper 的耦合度。 簡單的一句話，Asp.Net Core 真叫人愛不釋手。 參考範例 參考連結 Using Automapper In ASP.net Core AutoMapper Docs]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>C#</tag>
        <tag>AutoMapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo（3）－基本設定]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-3-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[有了第一個自己的 Blog，也順利的產身第一篇文章，接下來我們來做一些設定，讓 Blog 更量身打造一些。 請打開目錄下的 _config.yaml ，我們一步步調整。 Site 設定Site 是 Blog 的基本資訊，請修改基本的資訊上去。 12345678# Sitetitle: Hexosubtitle:description:keywords:author: John Doelanguage:timezone: URL 設定123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://raychiutw.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: url：Blog 的網址。 root：若網站有子目錄記得修改。&#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; permalink：若有 SEO 考量，可改為更簡短的設定 Directory 設定123456789# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: 本區使用預設值即可 Extensions 設定1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape theme：主題設定預設 landscape，後續會改使用 material。 Deployment 設定1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 部署的方式會是部署到 Github Pages，這部分有後續有專文說明 結論Hexo 預設的定義並不複雜，但是要讓他更完善好用仍須費一番心思調整，接著就來一一說明。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core 無法使用 DeploymentItem 的替代方案]]></title>
    <url>%2F2018%2FASP-NET-Core-%E7%84%A1%E6%B3%95%E4%BD%BF%E7%94%A8-DeploymentItem-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在 MSTest 中，若要在執行測試時能調用實體檔案，通常會用 DeploymentItem Attribute 來指定要同時部署的檔案，但屬性在 ASP.NET Core 中不再支援，本篇說明其他替代方案。 好用的 DeploymentItem在寫測試時，我們常會用以下作法調用外部檔案。 1234567891011121314151617using System.IO;using Microsoft.VisualStudio.TestTools.UnitTesting;namespace DeploymentItem.Tests&#123; [TestClass] public class UnitTestWithDeploymentItem &#123; [TestMethod] [DeploymentItem("TestData\\Sample.csv")] public void TestMethod1() &#123; var file = new StreamReader("Sample.csv"); // test code ... &#125; &#125;&#125; 完整使用說明 但在 ASP.NET Core 專案中使用 DeploymentItem 不會報錯，但測試執行後會找不到檔案（因為實際上沒有作用）！ 解決方式其實沒有什麼替代方式，就是不要用了，在程式碼直接指定明確的路徑就好了。 12345678910111213141516using System.IO;using Microsoft.VisualStudio.TestTools.UnitTesting;namespace DeploymentItem.Tests&#123; [TestClass] public class UnitTest1 &#123; [TestMethod] public void TestMethod1() &#123; var file = new StreamReader("TestData\\Sample.csv"); // test code ... &#125; &#125;&#125; 結案～ 範例程式連結https://github.com/raychiutw/asp-net-core-deploymentitem]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>MSTest</tag>
        <tag>UnitTest</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core 啟用 Web.config Transformation]]></title>
    <url>%2F2018%2FASP-NET-Core-%E5%95%9F%E7%94%A8-Web-config-Transformation%2F</url>
    <content type="text"><![CDATA[.Net Framework 4.0 提供了 Transformation 功能，讓 Web.Config 與 app.Config 可以依據組態設定建置不同的參數，這項好用的功能在 .Net Core 的專案中已無法作用，本文紀錄如何再次啟用這好用的功能。 情境說明ASP.NET Core 2.0 是靠 application.json 來取代 web.config，但有時候我們仍需要在 web.config 作一些環境參數切換，甚至有些第三方套件仍是倚賴 XML 做設定 (ex: Nlog.xml)，以下步驟將說明如何讓 ASP.NET Core 2.0 重新啟用 Transformation 環境說明 Visual Studio 2017 ASP.Net Core 2.0 加入 web.config 設定ASP.Net Core 範本專案沒有 web.config, 我們先手動新增並輸入以下設定。 1234567&lt;system.webServer&gt; &lt;aspNetCore processPath="%LAUNCHER_PATH%" arguments="%LAUNCHER_ARGS%" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout"&gt; &lt;environmentVariables&gt; &lt;environmentVariable name="ASPNETCORE_ENVIRONMENT" value="Development" /&gt; &lt;/environmentVariables&gt; &lt;/aspNetCore&gt;&lt;/system.webServer&gt; 再新增 web.release.config 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration xmlns:xdt="http://schemas.microsoft.com/XML-Document-Transform"&gt; &lt;system.webServer&gt; &lt;aspNetCore&gt; &lt;environmentVariables&gt; &lt;environmentVariable name="ASPNETCORE_ENVIRONMENT" xdt:Transform="Remove" xdt:Locator="Match(name)" /&gt; &lt;/environmentVariables&gt; &lt;/aspNetCore&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 在 web.config 中指定了環境變數為 Development，而 web.release.config 則在 release 組態建置時 將其移除，如此便達成了 Debug 組態時專案使用 application.development.json，Realese 組態使用 applictaion.json。 編輯 csproj接下來我們直接編輯 csproj，加入以下設定。 1234&lt;ItemGroup&gt; &lt;DotNetCliToolReference Include="Microsoft.DotNet.Xdt.Tools" Version="2.0.0" /&gt; ... 其他套件參考 ...&lt;/ItemGroup&gt; 請直接編輯 csproj，請勿使用 Nuget Manager 安裝。 在 &lt;/project&gt; 之前請輸入以下設定 12345678910&lt;Target Name="ApplyXdtConfigTransform" BeforeTargets="_TransformWebConfig"&gt; &lt;PropertyGroup&gt; &lt;_SourceWebConfig&gt;$(MSBuildThisFileDirectory)Web.config&lt;/_SourceWebConfig&gt; &lt;_XdtTransform&gt;$(MSBuildThisFileDirectory)Web.$(Configuration).config&lt;/_XdtTransform&gt; &lt;_TargetWebConfig&gt;$(PublishDir)Web.config&lt;/_TargetWebConfig&gt; &lt;/PropertyGroup&gt; &lt;Exec Command="dotnet transform-xdt --xml &amp;quot;$(_SourceWebConfig)&amp;quot; --transform &amp;quot;$(_XdtTransform)&amp;quot; --output &amp;quot;$(_TargetWebConfig)&amp;quot;" Condition="Exists('$(_XdtTransform)')" /&gt;&lt;/Target&gt; 主要的執行主體在 &lt;Exec /&gt; 區段，執行的時機設定在 BeforeTargets=&quot;_TransformWebConfig&quot; 完整參數說明如下 12345678.NET Core XML Document TransformationUsage: dotnet transform-xdt [options]Options: -?|-h|--help Show help information --xml|-x The path to the XML file to transform --transform|-t The path to the XDT transform file to apply --output|-o The path where the output (transformed) file will be written --verbose|-v Print verbose messages 發行專案接下來就來測試吧，發行 Debug 組態 與 Release 組態各建置一次， web.config 應如下方有正確的切換了。 Debug 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;!-- To customize the asp.net core module uncomment and edit the following section. For more info see https://go.microsoft.com/fwlink/?linkid=838655 --&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" resourceType="Unspecified" /&gt; &lt;/handlers&gt; &lt;aspNetCore processPath="dotnet" arguments=".\Transformation.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout"&gt; &lt;environmentVariables&gt; &lt;environmentVariable name="ASPNETCORE_ENVIRONMENT" value="Development" /&gt; &lt;/environmentVariables&gt; &lt;/aspNetCore&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;&lt;!--ProjectGuid: f0574043-a304-4eec-9e63-e3ef5d3184cd--&gt; Release 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;!-- To customize the asp.net core module uncomment and edit the following section. For more info see https://go.microsoft.com/fwlink/?linkid=838655 --&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" resourceType="Unspecified" /&gt; &lt;/handlers&gt; &lt;aspNetCore processPath="dotnet" arguments=".\Transformation.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout"&gt; &lt;environmentVariables&gt;&lt;/environmentVariables&gt; &lt;/aspNetCore&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;&lt;!--ProjectGuid: f0574043-a304-4eec-9e63-e3ef5d3184cd--&gt; 結論與補充 若是 ASP.NET Core 1.x 請參考 點我 範例只示範了 remove ，相關 XDT 語法請參考 MDSN XDT Reference 不同的 XML 皆可以用類似的設定做 Transformation 程式碼範例sample code 參考資料https://github.com/nil4/dotnet-transform-xdt]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>Transformation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（0）－目錄]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-0-%E7%9B%AE%E9%8C%84%2F</url>
    <content type="text"><![CDATA[Hexo 是一個使用 Node.js 為基礎的靜態網站產生器。使用 Markdown 解析文章，透過主題產生靜態檔案。而且他是由台灣人所開發出來的。 優點 台灣人開發，中文資源豐富。 Node.js 生態完整，插件完整。 頁面產生速度快。 缺點 Node.js 插件眾多，依賴複雜，有可能會踩坑。 Hexo _config.yaml 與 Hexo Theme _config.yaml 交互設定較複雜。 系列文章連結 Hexo教學（1）－快速安裝 Hexo教學（2）－建立第一篇文章 Hexo教學（3）－基本設定 Hexo教學（4）－部署到 GitHub Pages Hexo教學（5）－Material 主題設定 Hexo教學（6）－Material 程式碼高亮 Hexo教學（7）－Material 整合功能 Hexo教學（8）－Material RSS QRCode 站內搜尋 Hexo教學（9）－Sitemap.xml 與 robot.txt]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（2）－第一篇文章]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-2-%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[快速建立第一個 Bolg 之後，接下當然是來產生第一篇文章。 用指令產生文章Hexo new “文章名稱” 可以快速產生一個 markdown 出來，產生的檔案放在 /source/post/ 下。 1npm new first-post 產生靜態檔還記得上篇說提，Hexo 是將 markdown 產生靜態 html 的框架，有了 markdown 後，那就讓我們來產生靜態檔吧。 1hexo generate 或者 1hexo g 檢查 /public/ 下是否有剛剛那篇的 html 了呢？ 讓我們再去看看 http://localhost:4000 是否有新文章了。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（1）－快速安裝]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-1-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%2F</url>
    <content type="text"><![CDATA[那我們就開始吧。 安裝 Node.js下載Node.js 安裝 Hexo1npm install -g hexo-cli 建立第一個 Blog請在想要的目錄下打開命令列視窗。 123hexo init myblogcd myblognpm install 執行站台1hexo server 或者 1hexo s 在瀏覽器輸入 http://localhost:4000 有看到下圖就成功建立第一個部落格站囉。 。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Static Site Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[開張大吉]]></title>
    <url>%2F2018%2F%E9%96%8B%E5%BC%B5%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[為什麼想寫部落格？ 為什麼到這把年紀才想寫部落格？ 其實！就是因為這把年紀阿！！ 最近我的老闆突然問我：Ray！你的代表作是什麼？ 我瞬間卡彈無法回答 這些年我也累積了不少東西但是我卻回答不出來，真的是年紀大了，看來得靠一些文字來記錄了． 於是乎寫部落格的想法就這樣油然而生了！ 稍微查了一下主要分為兩種方式 使用BSP（痞客邦，Blogger等等） 自建網站 （WordPress） 使用 BSP 是最省事的，但一旦業者不玩了，備份文章或搬家這真的是一場災難，而我只想保留我的心得，並未肖想成為部落客，能夠好好的保存資料才是最重要的．自建網站符合我的目的，但入門門檻實在不低，網路空間，網域，還有非我擅長的WordPress． 後來找到了 GitHub Pages，可以免費的使用，但只限定靜態頁面，原生支持 Jekyll （將 Markdown 生成靜態網頁的開源服務），試用了一陣子發現有些想要的功能要自行在安裝出來實在不容易． 最後找到了 Hexo，一套類似 Jekyll 但基於 Node.js 運行的軟體，經過幾天的安裝設定，把想要的樣式與功能都做好，成為目前部落格的樣子．接下來會把使用上的心得寫出來，總之 萬事起頭難，而我開始了！]]></content>
      <categories>
        <category>雜記</category>
      </categories>
  </entry>
</search>
