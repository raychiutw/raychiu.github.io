<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[隨手 Design Pattern (6) - 單例模式 (Singleton Pattern)]]></title>
    <url>%2F2019%2F%E9%9A%A8%E6%89%8B-Design-Pattern-6-%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern%2F</url>
    <content type="text"><![CDATA[單例模式是軟件工程中最著名的模式之一。從本質上講，單例是一個只允許創建自身的單個實例的類，通常可以簡單地訪問該實例。最常見的是，單例在創建實例時不允許指定任何參數 - 否則對實例的第二個請求但具有不同的參數可能會有問題！（如果對於具有相同參數的所有請求，應訪問相同的實例，則工廠模式更合適。）本文僅處理不需要參數的情況。通常，單例的要求是它們是懶惰地創建的 - 即在第一次需要之前不創建實例。 總結 Singleton 模式有兩個特點 單一實例 (Single Instance) 延遲建立實例 (Lazy Instantiation) C# 實作在C＃中實現單例模式有各種不同的方法。從最常見的，不是執行緒安全的，以及完全延遲加載，安全，簡單且高性能的版本開始。 而有此共同特徵： 單個構造函數，它是私有且無參數的。這可以防止其他類實例化它（這將違反模式）。(C#來說類別必須 sealed ，且 建構式為 private) 一個靜態變量，用於保存對單個已創建實例的引用。(C# 來說需要一個 public 與 statc 的 ) 公共靜態意味著獲取對單個創建實例的引用，必要時創建一個實例。(C# 來說類別需 public 與 static) 非執行緒安全 Singleton這是個不好的案例，此方式不是執行緒安全，無法確保在多執行緒情況下是唯一的實例。 123456789101112131415161718192021public sealed class NotThreadSafeSingleton&#123; private static NotThreadSafeSingleton _instance = null; private NotThreadSafeSingleton() &#123; &#125; public static NotThreadSafeSingleton Instance &#123; get &#123; if (_instance == null) &#123; _instance = new NotThreadSafeSingleton(); &#125; return _instance; &#125; &#125;&#125; 簡單執行緒安全 Singleton使用 Lock 來確保執行緒安全。 1234567891011121314151617181920212223 private static readonly object padlock = new object(); private static SimpleThreadSafetySingleton _instance = null; private SimpleThreadSafetySingleton() &#123; &#125; public static SimpleThreadSafetySingleton Instance &#123; get &#123; lock (padlock) &#123; if (_instance == null) &#123; _instance = new SimpleThreadSafetySingleton(); &#125; return _instance; &#125; &#125; &#125;&#125; 使用 Double-checked Locking 確保執行緒安全使用 Double-checked Locking 確保執行緒安全。 12345678910111213141516171819202122232425public sealed class DoubleCheckedLockingSingleton&#123; private static readonly object padlock = new object(); private static DoubleCheckedLockingSingleton _instance = null; //用來LOCK建立instance的程序。 public static DoubleCheckedLockingSingleton Instance &#123; get &#123; if (_instance == null) &#123; lock (padlock) &#123; if (_instance == null) &#123; _instance = new DoubleCheckedLockingSingleton(); &#125; &#125; &#125; return _instance; &#125; &#125;&#125; 不使用 Lock, 確保執行緒安全 (非 Lazy)此範例沒有使用 Lock, 而仍是執行緒安全的 Singleton，但不是 Lazy。 123456789 public sealed class EagerSingleton &#123; private EagerSingleton() &#123; &#125; public static EagerSingleton Instance &#123; get; &#125; = new EagerSingleton(); &#125;&#125; 完整 Lazy 實例此範例達成了延遲建立。 1234567891011121314151617181920212223public sealed class LazySingleton&#123; private LazySingleton() &#123; &#125; public static LazySingleton Instance &#123; get &#123; return InnerClass.Instance; &#125; &#125; private class InnerClass &#123; internal static readonly LazySingleton Instance = new LazySingleton(); static InnerClass() &#123; &#125; &#125;&#125; 使用 .NET 4 的 Lazy&lt;T&gt;此方式使用後 .Net Framework 4 之後提供的 Lazy&lt;T&gt;，如此可以簡單的達成 Singleton 要求的 唯一 與 延遲建立。 12345678910public sealed class DotNet4LazySingleton&#123; private static readonly Lazy&lt;DotNet4LazySingleton&gt; lazy = new Lazy&lt;DotNet4LazySingleton&gt;(() =&gt; new DotNet4LazySingleton()); private DotNet4LazySingleton() &#123; &#125; public static DotNet4LazySingleton Instance &#123; get &#123; return lazy.Value; &#125; &#125;&#125; 結語除了第一個範例不建議之外，其餘的是可以依實際情況斟酌使用。 程式碼範例]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>C#</tag>
        <tag>Singleton Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隨手 Design Pattern (5) - 雙重檢查鎖定模式 (Double-Checked Locking Pattern)]]></title>
    <url>%2F2019%2F%E9%9A%A8%E6%89%8B-Design-Pattern-5-%E9%9B%99%E9%87%8D%E6%AA%A2%E6%9F%A5%E9%8E%96%E5%AE%9A%E6%A8%A1%E5%BC%8F-Double-Checked-Locking-Pattern%2F</url>
    <content type="text"><![CDATA[雙重檢查鎖定 (Double-Checked Locking Pattern) 是另外一個常用的設計模式，用來減少並發系統中競爭和同步的開銷。雙重檢查鎖定模式首先驗證鎖定條件(第一次檢查)，只有通過鎖定條件驗證才真正的進行加鎖邏輯並再次驗證條件(第二次檢查)。常用來避免快取在同一時間被重複建立。 定義我們先來看看來自 Wiki 的定義 雙重檢查鎖定模式（也被稱為”雙重檢查加鎖優化”，”鎖暗示”（Lock hint）[1]) 是一種軟體設計模式用來減少並發系統中競爭和同步的開銷。雙重檢查鎖定模式首先驗證鎖定條件(第一次檢查)，只有通過鎖定條件驗證才真正的進行加鎖邏輯並再次驗證條件(第二次檢查)。該模式在某些語言在某些硬體平台的實現可能是不安全的。有的時候，這一模式被看做是反模式。它通常用於減少加鎖開銷，尤其是為多執行緒環境中的單例模式實現「惰性初始化」。惰性初始化的意思是直到第一次訪問時才初始化它的值。 C# 實際範例在一般的情境下，我最常使用在快取建立的情境，在快取要建立前，使用 Double-Checked Locking 防止快取的重複建立。 使用快取範例先來說明 ASP.NET Core 下如何使用快取，範例是使用 WebApi 專案範本。 Startup 註冊 MemoryCache 12345678910111213141516171819using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.DependencyInjection;public class Startup&#123; public void ConfigureServices(IServiceCollection services) &#123; // Register MemoryCache services.AddMemoryCache(); services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); &#125; public void Configure(IApplicationBuilder app) &#123; app.UseMvcWithDefaultRoute(); &#125;&#125; 再來 Contorller 以下設定 1234567891011121314151617181920212223242526272829303132333435363738using System;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Caching.Memory;namespace DoubleCheckedLocking.WebApplication.Controllers&#123; [Route("api/[controller]")] [ApiController] public class ValuesController : ControllerBase &#123; private IMemoryCache _cache; public ValuesController(IMemoryCache memoryCache) &#123; this._cache = memoryCache; &#125; // 取得快取值 var cacheEntry = this._cache.Get&lt;DateTime&gt;("key"); // 快取檢查 if (this._cache.Get&lt;DateTime&gt;("key") == null) &#123; // 無快取, 所以重新取值 cacheEntry = DateTime.Now; // 設定快取過期時間 var cacheEntryOptions = new MemoryCacheEntryOptions() .SetAbsoluteExpiration(TimeSpan.FromSeconds(3)); // 加入快取 _cache.Set("key", cacheEntry, cacheEntryOptions); &#125; return cacheEntry.ToString(); &#125; &#125;&#125; 會遇到的問題當大量連線請求執行這段程式碼的時候，是有可能在極短暫時間下，快取不存在的鎖定判斷會被通過多次請求，而導致快取被重複建立，而當快取建立的成本很高的時候(比如說連接資料庫)，更可能造成後端的負載壓力，在筆者工作環境中，是個同時上線人數達 2000 人的大系統是，屢屢遇到快取鎖定失效導致資料庫負擔過重的案例，這時候 Double-Checked Locking 便派上用場，讓我們將快取的程式碼繼續導入 Double-Checked Locking。 1234567891011121314151617181920212223242526272829303132 // GET api/values [HttpGet] public ActionResult&lt;string&gt; Get() &#123; // 取得快取值 var cacheEntry = this._cache.Get&lt;DateTime&gt;("key"); // 第一次檢查 if (cacheEntry == null) &#123; // 鎖定 lock (padlock) &#123; // 第二次檢查 if (this._cache.Get&lt;DateTime&gt;("key") == null) &#123; // 無快取, 所以重新取值 cacheEntry = DateTime.Now; // 設定快取過期時間 var cacheEntryOptions = new MemoryCacheEntryOptions() .SetAbsoluteExpiration(TimeSpan.FromSeconds(3)); // 加入快取 _cache.Set("key", cacheEntry, cacheEntryOptions); &#125; &#125; &#125; return cacheEntry.ToString(); &#125;&#125; 這裡要注意的是，第二次的檢查務必重新取得快取來判斷，若繼續沿用第一次檢查的變數，將會導致無效檢查。 結語Double-Checked Locking 在快取情境下使用非常適合，另外一個適用情境是單例模式 (Singleton Pattern)，之後講到 Singleton 再說明囉。 程式碼範例]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>C#</tag>
        <tag>Double-Checked Locking Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隨手 Design Pattern (4) - Repository 模式 (Repository Pattern)]]></title>
    <url>%2F2019%2F%E9%9A%A8%E6%89%8B-Design-Pattern-4-Repository-%E6%A8%A1%E5%BC%8F-Repository-Pattern%2F</url>
    <content type="text"><![CDATA[Repository 模式與 UnitOfWork 模式可說是充滿爭議，國外大神爭論不休，本篇不打算加入筆戰，只簡單提供幾個適合的應用的情境與範例，大家就自行選擇消化囉。 Repository 模式的好處在軟體分層那篇文章中，資料存取層的實作便是 Repository 模式的體現，有效的將資料存取隔離於商業邏輯之外，當要抽換資料來源時，無須改動展示層與商業邏輯層(前提是 Repoistory 約定的介面沒有變動)。 專用型 IRepository 與 泛型 IRepository我們先定義兩種應用的模式 專用型 Repository：一個 interface 實作 一個 Repository 12345678910111213141516171819public interface IBlogRepository&#123; // ....&#125;public class BlogRepository : IBlogRepository&#123; // ....&#125;public interface IPostRepository&#123; // ....&#125;public class PostRepository : IPostRepository&#123; // ....&#125; 泛型 Repository：一個 interface 實作 一個 Repository，透過不同的 TEntity 來操作不同的資料表。 123456789public interface IGenericRepository&lt;TEntity&gt;&#123; // ....&#125;public class GenericRepository : GenericRepository&lt;TEntity&gt;&#123; // ....&#125; 當 Repository 有不同的介面方法的時候，專用型 Repository 能提供最大的彈性。 當 Repoitory 有固定的 CRUD 的介面方法，泛型 Repository 可以有效的減少重複的程式碼。 專用型 Repository 模式 with Daaper而該架構對於 Dapper 這類輕量型 ORM 可以說搭配的如魚得水，因為 Dapper 執行我們定義好的 sqlcommand，專注在強型別的操作，故對於 Repository 的介面並無直接的對應操作，也讓程式設計師有了較大的彈性去定義介面的方法，下面程式範例是專用型的寫法，改成泛型也是可以的喔。 DapperHelper使用 Dapper 建議作個 DapperHelper 來隔離。 12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt;/// Database 介面/// &lt;/summary&gt;public interface IDatabaseHelper&#123; /// &lt;summary&gt; /// 取得連線 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IDbConnection GetConnection();&#125;/// &lt;summary&gt;/// DatabaseHelper/// &lt;/summary&gt;/// &lt;seealso cref="Sample.Repository.Infrastructure.IDatabaseHelper" /&gt;public class DatabaseHelper : IDatabaseHelper&#123; private readonly string _connectionString; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="DatabaseHelper"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="connectionString"&gt;The database.&lt;/param&gt; public DatabaseHelper(string connectionString) &#123; this._connectionString = connectionString; &#125; /// &lt;summary&gt; /// 取得連線 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public IDbConnection GetConnection() &#123; var conn = new SqlConnection(this._connectionString); return conn; &#125;&#125; Respository1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// Interface BlogRepository/// &lt;/summary&gt;public interface IBlogRepository&#123; /// &lt;summary&gt; /// 新增 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;Blog 實體&lt;/param&gt; Task&lt;int&gt; AddAsync(Blog blog); /// &lt;summary&gt; /// 取得所有 Blog /// &lt;/summary&gt; /// &lt;param name="blogQuery"&gt;查詢條件&lt;/param&gt; Task&lt;IEnumerable&lt;Blog&gt;&gt; GetAsync(BlogQuery blogQuery); /// &lt;summary&gt; /// 刪除 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;Blog 實體&lt;/param&gt; Task&lt;int&gt; RemoveAsync(Blog blog); /// &lt;summary&gt; /// 更新 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;Blog 實體&lt;/param&gt; Task&lt;int&gt; UpdateAsync(Blog blog);&#125; Repository 實作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/// &lt;summary&gt;/// BlogRepository/// &lt;/summary&gt;public class BlogRepository : IBlogRepository&#123; /// &lt;summary&gt; /// The database /// &lt;/summary&gt; private readonly IDatabaseHelper _databaseHelper; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name="databaseHelper"&gt;&lt;/param&gt; public BlogRepository(IDatabaseHelper databaseHelper) &#123; this._databaseHelper = databaseHelper; &#125; /// &lt;summary&gt; /// 新增 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;Blog 實體&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; AddAsync(Blog blog) &#123; // 資料庫實作 using (IDbConnection conn = this._databaseHelper.GetConnection()) &#123; string sql = @" INSERT INTO Blog VALUES ( @BlogId, @Url );"; var count = await conn.ExecuteAsync( sql, new &#123; blog.BlogId, blog.Url &#125;); return count; &#125; &#125; /// &lt;summary&gt; /// 取得所有 Blog /// &lt;/summary&gt; /// &lt;param name="blogQuery"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;IEnumerable&lt;Blog&gt;&gt; GetAsync(BlogQuery blogQuery) &#123; // 資料庫實作 using (IDbConnection conn = this._databaseHelper.GetConnection()) &#123; string sql = @" SELECT BlogId, Url FROM Blog WHERE BlogId = @BlogId OR Url = @Url"; var Blogs = await conn.QueryAsync&lt;Blog&gt;( sql, new &#123; blogQuery.BlogId, blogQuery.Url &#125;); return Blogs; &#125; &#125; /// &lt;summary&gt; /// 刪除 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;Blog 實體&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; RemoveAsync(Blog blog) &#123; // 資料庫實作 using (IDbConnection conn = this._databaseHelper.GetConnection()) &#123; string sql = @"DELETE FROM Blog WHERE BlogId = @BlogId"; var count = await conn.ExecuteAsync( sql, new &#123; blog.BlogId &#125;); return count; &#125; &#125; /// &lt;summary&gt; /// 更新 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;Blog 實體&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; UpdateAsync(Blog blog) &#123; // 資料庫實作 using (IDbConnection conn = this._databaseHelper.GetConnection()) &#123; string sql = @" UPDATE Blog SET BlogId = @BlogId, Url = @Url );"; var count = await conn.ExecuteAsync( sql, new &#123; blog.BlogId, blog.Url &#125;); return count; &#125; &#125;&#125; Service 的應用注入 IBlogRepository 就可以使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt;/// BlogService/// &lt;/summary&gt;public class BlogService : IBlogService&#123; private IBlogRepository _blogRepository; private IMapper _mapper; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BlogService"/&gt; class. /// &lt;/summary&gt; public BlogService( IBlogRepository blogRepository, IMapper mapper) &#123; this._blogRepository = blogRepository; this._mapper = mapper; &#125; /// &lt;summary&gt; /// 新增 Blog /// &lt;/summary&gt; /// &lt;param name="blogDto"&gt;Blog Dto&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; AddAsync(BlogDto blogDto) &#123; // Convert BlogDto to Blog var blog = this._mapper.Map&lt;Blog&gt;(blogDto); return await this._blogRepository.AddAsync(blog); ; &#125; /// &lt;summary&gt; /// 取得 Blog /// &lt;/summary&gt; /// &lt;param name="blogQueryDto"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;IEnumerable&lt;BlogDto&gt;&gt; GetAsync(BlogQueryDto blogQueryDto) &#123; // Convert BlogQueryDto to BlogQuery var blogQuery = this._mapper.Map&lt;BlogQuery&gt;(blogQueryDto); var blogs = await this._blogRepository.GetAsync(blogQuery); // Convert Blog to BlogDto var blogDtos = this._mapper.Map&lt;IEnumerable&lt;BlogDto&gt;&gt;(blogs); return blogDtos; &#125; /// &lt;summary&gt; /// 刪除 Blog /// &lt;/summary&gt; /// &lt;param name="blogId"&gt;Blog Id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; RemoveAsync(int blogId) &#123; return await this._blogRepository.RemoveAsync(new Blog() &#123; BlogId = blogId &#125;); &#125; /// &lt;summary&gt; /// 修改 Blog /// &lt;/summary&gt; /// &lt;param name="blogDto"&gt;Blog Dto&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; UpdateAsync(BlogDto blogDto) &#123; // Convert BlogDto to Blog var blog = this._mapper.Map&lt;Blog&gt;(blogDto); return await this._blogRepository.UpdateAsync(blog); &#125;&#125; 注入設定Startup.cs 的注入設定 123456789101112131415/// &lt;summary&gt;/// This method gets called by the runtime. Use this method to add services to the container./// &lt;/summary&gt;/// &lt;param name="services"&gt;&lt;/param&gt;public void ConfigureServices(IServiceCollection services)&#123; var connection = this.Configuration.GetConnectionString("DefaultConnection"); // DI Register services.AddScoped&lt;IBlogService, BlogService&gt;(); services.AddScoped&lt;IBlogRepository, BlogRepository&gt;(); services.AddScoped&lt;IDatabaseHelper&gt;(x =&gt; new DatabaseHelper(connection)); ///..............&#125; 專用型 Repository with Dapper 程式碼範例 專用型 Repository 模式 with EFCore專用型 IRepository 搭配 EFCore 只需抽換 DapperHelper 的部分即可。 DBContextEFCore 使用指定產生出 DBContext 如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/// &lt;summary&gt;////// &lt;/summary&gt;/// &lt;seealso cref="Microsoft.EntityFrameworkCore.DbContext" /&gt;public partial class BloggingContext : DbContext&#123; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BloggingContext"/&gt; class. /// &lt;/summary&gt; public BloggingContext() &#123; &#125; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BloggingContext"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="options"&gt;The options.&lt;/param&gt; public BloggingContext(DbContextOptions&lt;BloggingContext&gt; options) : base(options) &#123; &#125; /// &lt;summary&gt; /// blog. /// &lt;/summary&gt; public virtual DbSet&lt;Blog&gt; Blog &#123; get; set; &#125; /// &lt;summary&gt; /// post. /// &lt;/summary&gt; public virtual DbSet&lt;Post&gt; Post &#123; get; set; &#125; /// &lt;summary&gt; /// &lt;para&gt; /// Override this method to configure the database (and other options) to be used for this context. /// This method is called for each instance of the context that is created. /// The base implementation does nothing. /// &lt;/para&gt; /// &lt;para&gt; /// In situations where an instance of &lt;see cref="T:Microsoft.EntityFrameworkCore.DbContextOptions" /&gt; may or may not have been passed /// to the constructor, you can use &lt;see cref="P:Microsoft.EntityFrameworkCore.DbContextOptionsBuilder.IsConfigured" /&gt; to determine if /// the options have already been set, and skip some or all of the logic in /// &lt;see cref="M:Microsoft.EntityFrameworkCore.DbContext.OnConfiguring(Microsoft.EntityFrameworkCore.DbContextOptionsBuilder)" /&gt;. /// &lt;/para&gt; /// &lt;/summary&gt; /// &lt;param name="optionsBuilder"&gt;A builder used to create or modify options for this context. Databases (and other extensions) /// typically define extension methods on this object that allow you to configure the context.&lt;/param&gt; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123; &#125; /// &lt;summary&gt; /// Override this method to further configure the model that was discovered by convention from the entity types /// exposed in &lt;see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" /&gt; properties on your derived context. The resulting model may be cached /// and re-used for subsequent instances of your derived context. /// &lt;/summary&gt; /// &lt;param name="modelBuilder"&gt;The builder being used to construct the model for this context. Databases (and other extensions) typically /// define extension methods on this object that allow you to configure aspects of the model that are specific /// to a given database.&lt;/param&gt; /// &lt;remarks&gt; /// If a model is explicitly set on the options for this context (via &lt;see cref="M:Microsoft.EntityFrameworkCore.DbContextOptionsBuilder.UseModel(Microsoft.EntityFrameworkCore.Metadata.IModel)" /&gt;) /// then this method will not be run. /// &lt;/remarks&gt; protected override void OnModelCreating(ModelBuilder modelBuilder) &#123; modelBuilder.HasAnnotation("ProductVersion", "2.2.6-servicing-10079"); modelBuilder.Entity&lt;Blog&gt;(entity =&gt; &#123; entity.Property(e =&gt; e.Url).IsRequired(); &#125;); modelBuilder.Entity&lt;Post&gt;(entity =&gt; &#123; entity.HasOne(d =&gt; d.Blog) .WithMany(p =&gt; p.Post) .HasForeignKey(d =&gt; d.BlogId); &#125;); &#125;&#125; Repository with DBContext 實作Repository 介面與 Service 使用都不需修改，只需修改 Repository 實作的部分 (有沒有開始感受到分層抽離，依賴建介面的好處？) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/// &lt;summary&gt;/// Class BlogRepository./// Implements the &lt;see cref="Sample.Repository.Interface.IBlogRepository" /&gt;/// &lt;/summary&gt;/// &lt;seealso cref="Sample.Repository.Interface.IBlogRepository" /&gt;public class BlogRepository : IBlogRepository&#123; /// &lt;summary&gt; /// The database /// &lt;/summary&gt; private readonly BloggingContext _context; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BlogRepository"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="context"&gt;The context.&lt;/param&gt; public BlogRepository(BloggingContext context) &#123; this._context = context; &#125; /// &lt;summary&gt; /// 新增 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;實體&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;bool&gt; AddAsync(Blog blog) &#123; _context.Add(blog); var count = await _context.SaveChangesAsync(); return count &gt; 0; &#125; /// &lt;summary&gt; /// 取得 Blog /// &lt;/summary&gt; /// &lt;param name="condition"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;IEnumerable&lt;Blog&gt;&gt; GetAsync(BlogQuery condition) &#123; var blogs = await _context.Blog.ToListAsync(); return blogs; &#125; /// &lt;summary&gt; /// 刪除 Blog /// &lt;/summary&gt; /// &lt;param name="id"&gt;blog id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;bool&gt; RemoveAsync(int id) &#123; var blog = await _context.Blog.FindAsync(id); _context.Blog.Remove(blog); var count = await _context.SaveChangesAsync(); return count &gt; 0; &#125; /// &lt;summary&gt; /// 更新 Blog /// &lt;/summary&gt; /// &lt;param name="blog"&gt;實體&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;bool&gt; UpdateAsync(Blog blog) &#123; _context.Update(blog); var count = await _context.SaveChangesAsync(); return count &gt; 0; &#125;&#125; EFCore 的注入寫法如下123456789101112131415161718/// &lt;summary&gt;/// This method gets called by the runtime. Use this method to add services to the container./// &lt;/summary&gt;/// &lt;param name="services"&gt;&lt;/param&gt;public void ConfigureServices(IServiceCollection services)&#123; var connection = this.Configuration.GetConnectionString("DefaultConnection"); // DI Register services.AddScoped&lt;IBlogService, BlogService&gt;(); services.AddScoped&lt;IBlogRepository, BlogRepository&gt;(); services.AddDbContext&lt;BloggingContext&gt;( options =&gt; options.UseSqlServer(connection)); services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); ///...............&#125; 專用型 Repository with EFCore 程式碼範例 泛型 Repository 模式 with EFCore若按照上面的定義，EF 定義了每個 Entity 就是一個資料表，所以要搭配 Repository 模式 應該就是適合泛型 IRepository 囉 ? 答案是：不盡然，目前兩派爭論不休。 一派說法是: EF 的 Entity 其實完整實作了 CRUD 功能，如此再包一層 IRepository 定義的 CURD 是多此一舉? 而另一派說法則是:為了要隔離 EF 多一層 Repository 是必須的。 這兩派的說法其實個有道理，大家就採用自己相信的說法吧。而我是比較支持隔離這層的。 泛型 IRepository123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt;/// Interface Repository/// &lt;/summary&gt;public interface IGenericRepository&lt;TEntity&gt; where TEntity : class&#123; /// &lt;summary&gt; /// 新增 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; void Add(TEntity entity); /// &lt;summary&gt; /// 取得全部 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;ICollection&lt;TEntity&gt;&gt; GetAllAsync(); /// &lt;summary&gt; /// 取得單筆 /// &lt;/summary&gt; /// &lt;param name="predicate"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;TEntity&gt; GetAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate); /// &lt;summary&gt; /// 刪除 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; void Remove(TEntity entity); /// &lt;summary&gt; /// 更新 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; void Update(TEntity entity);&#125; 泛型 IRepository 實作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/// &lt;summary&gt;////// &lt;/summary&gt;/// &lt;typeparam name="TEntity"&gt;The type of the entity.&lt;/typeparam&gt;/// &lt;seealso cref="Sample.Repository.Interface.IGenericRepository&#123;TEntity&#125;" /&gt;public class GenericRepository&lt;TEntity&gt; : IGenericRepository&lt;TEntity&gt; where TEntity : class&#123; /// &lt;summary&gt; /// UnitOfWork 實體 /// &lt;/summary&gt; private readonly IUnitOfWork _unitOfWork; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="GenericRepository&#123;TEntity&#125;"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="unitofwork"&gt;The unitofwork.&lt;/param&gt; public GenericRepository(IUnitOfWork unitofwork) &#123; this._unitOfWork = unitofwork; &#125; /// &lt;summary&gt; /// 新增 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; public void Add(TEntity entity) &#123; if (entity == null) &#123; throw new ArgumentNullException("entity"); &#125; _unitOfWork.Context.Set&lt;TEntity&gt;().Add(entity); &#125; /// &lt;summary&gt; /// 取得全部 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;ICollection&lt;TEntity&gt;&gt; GetAllAsync() &#123; return await this._unitOfWork.Context.Set&lt;TEntity&gt;().ToListAsync(); &#125; /// &lt;summary&gt; /// 取得單筆 /// &lt;/summary&gt; /// &lt;param name="predicate"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;TEntity&gt; GetAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate) &#123; return await this._unitOfWork.Context.Set&lt;TEntity&gt;().FirstOrDefaultAsync(predicate); &#125; /// &lt;summary&gt; /// 刪除 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; public void Remove(TEntity entity) &#123; if (entity == null) &#123; throw new ArgumentNullException("entity"); &#125; this._unitOfWork.Context.Entry(entity).State = EntityState.Deleted; &#125; /// &lt;summary&gt; /// 更新 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; public void Update(TEntity entity) &#123; if (entity == null) &#123; throw new ArgumentNullException("entity"); &#125; this._unitOfWork.Context.Entry(entity).State = EntityState.Modified; &#125;&#125; 注入1234567891011121314/// &lt;summary&gt;/// This method gets called by the runtime. Use this method to add services to the container./// &lt;/summary&gt;/// &lt;param name="services"&gt;&lt;/param&gt;public void ConfigureServices(IServiceCollection services)&#123; var connection = this.Configuration.GetConnectionString("DefaultConnection"); // DI Register services.AddScoped&lt;IBlogService, BlogService&gt;(); services.AddScoped&lt;IGenericRepository&lt;Blog&gt;, GenericRepository&lt;Blog&gt;&gt;(); services.AddScoped&lt;DbContext, BloggingContext&gt;(); services.AddDbContext&lt;BloggingContext&gt;( options =&gt; options.UseSqlServer(connection)); 泛型 Repository wit EF Core 範例 此範例為簡單情境，只有一個 BlogRepositoy，故在 Startup.cs 作簡單註冊，若是有多個 Repository 可以用以下兩種方式 方法1 : Register with keyDI 設定 123456789101112131415161718services.AddScoped&lt;ServiceA&gt;();services.AddScoped&lt;ServiceB&gt;();services.AddScoped&lt;ServiceC&gt;();services.AddScoped&lt;ServiceResolver&gt;(serviceProvider =&gt; key =&gt;&#123; switch (key) &#123; case "A": return serviceProvider.GetService&lt;ServiceA&gt;(); case "B": return serviceProvider.GetService&lt;ServiceB&gt;(); case "C": return serviceProvider.GetService&lt;ServiceC&gt;(); default: throw new KeyNotFoundException(); // or maybe return null, up to you &#125;&#125;); 產生實體 1234567891011121314public class Consumer&#123; private readonly IService _aService; public Consumer(ServiceResolver serviceAccessor) &#123; _aService = serviceAccessor("A"); &#125; public void UseServiceA() &#123; _aService.DoTheThing(); &#125;&#125; 方法2 : 實作多個 Repository，各別註冊12services.AddScoped&lt;IBlogRepository,BlogRepository();services.AddScoped&lt;IPostRepository,PostRepository(); BlogRepository, PostRepository 實作 IGenericRepository。 Repository Pattern &amp; Unit Of Work (常見用法版)一步步說明 UnitOfWork IRepository 與 Service 的問題若事情只到這也就還好，但當 UnitOfWork 也進來之後，事情變得更複雜，主要原因是一般提供的 UnitOfWork 的作法有其問題，我們來一步步說明。 首先，關於IUnitOfWork 的定義實現 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// &lt;summary&gt;/// UnitOfWork 介面/// &lt;/summary&gt;/// &lt;seealso cref="System.IDisposable" /&gt;public interface IUnitOfWork : IDisposable&#123; /// &lt;summary&gt; /// DB Context /// &lt;/summary&gt; DbContext Context &#123; get; &#125; /// &lt;summary&gt; /// Saves the change. /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;int&gt; SaveChangeAsync();&#125;/// &lt;summary&gt;/// UnitOfWork/// &lt;/summary&gt;public class UnitOfWork : IUnitOfWork&#123; /// &lt;summary&gt; /// /// &lt;/summary&gt; private bool disposed = false; /// &lt;summary&gt; /// 建構式 /// &lt;/summary&gt; /// &lt;param name="context"&gt;&lt;/param&gt; public UnitOfWork(DbContext context) &#123; this.Context = context; &#125; /// &lt;summary&gt; /// Context /// &lt;/summary&gt; public DbContext Context &#123; get; private set; &#125; /// &lt;summary&gt; /// Dispose /// &lt;/summary&gt; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; /// &lt;summary&gt; /// SaveChange /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; SaveChangeAsync() &#123; return await this.Context.SaveChangesAsync(); &#125; /// &lt;summary&gt; /// Dispose /// &lt;/summary&gt; /// &lt;param name="disposing"&gt;&lt;/param&gt; protected virtual void Dispose(bool disposing) &#123; if (!this.disposed) &#123; if (disposing) &#123; this.Context.Dispose(); this.Context = null; &#125; &#125; this.disposed = true; &#125;&#125; 接下來進行 Repository 的修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/// &lt;summary&gt;////// &lt;/summary&gt;/// &lt;typeparam name="TEntity"&gt;The type of the entity.&lt;/typeparam&gt;/// &lt;seealso cref="Sample.Repository.Interface.IGenericRepository&#123;TEntity&#125;" /&gt;public class GenericRepository&lt;TEntity&gt; : IGenericRepository&lt;TEntity&gt; where TEntity : class&#123; /// &lt;summary&gt; /// UnitOfWork 實體 /// &lt;/summary&gt; private readonly IUnitOfWork _unitOfWork; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="GenericRepository&#123;TEntity&#125;"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="unitofwork"&gt;The unitofwork.&lt;/param&gt; public GenericRepository(IUnitOfWork unitofwork) &#123; this._unitOfWork = unitofwork; &#125; /// &lt;summary&gt; /// 新增 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; /// &lt;exception cref="ArgumentNullException"&gt;entity&lt;/exception&gt; public void Add(TEntity entity) &#123; if (entity == null) &#123; throw new ArgumentNullException("entity"); &#125; _unitOfWork.Context.Set&lt;TEntity&gt;().Add(entity); &#125; /// &lt;summary&gt; /// 取得全部 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;ICollection&lt;TEntity&gt;&gt; GetAllAsync() &#123; return await this._unitOfWork.Context.Set&lt;TEntity&gt;().ToListAsync(); &#125; /// &lt;summary&gt; /// 取得單筆 /// &lt;/summary&gt; /// &lt;param name="predicate"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;TEntity&gt; GetAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate) &#123; return await this._unitOfWork.Context.Set&lt;TEntity&gt;().FirstOrDefaultAsync(predicate); &#125; /// &lt;summary&gt; /// 刪除 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; /// &lt;exception cref="ArgumentNullException"&gt;entity&lt;/exception&gt; public void Remove(TEntity entity) &#123; if (entity == null) &#123; throw new ArgumentNullException("entity"); &#125; this._unitOfWork.Context.Entry(entity).State = EntityState.Deleted; &#125; /// &lt;summary&gt; /// 更新 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;實體&lt;/param&gt; /// &lt;exception cref="ArgumentNullException"&gt;entity&lt;/exception&gt; public void Update(TEntity entity) &#123; if (entity == null) &#123; throw new ArgumentNullException("entity"); &#125; this._unitOfWork.Context.Entry(entity).State = EntityState.Modified; &#125;&#125; 再來是 Service 的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/// &lt;summary&gt;/// BlogService/// &lt;/summary&gt;public class BlogService : IBlogService&#123; private IGenericRepository&lt;Blog&gt; _blogRepository; private IMapper _mapper; private IUnitOfWork _unitofwork; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BlogService"/&gt; class. /// &lt;/summary&gt; public BlogService( IUnitOfWork unitofwork, IGenericRepository&lt;Blog&gt; blogRepository, IMapper mapper) &#123; this._unitofwork = unitofwork; this._blogRepository = blogRepository; this._mapper = mapper; &#125; /// &lt;summary&gt; /// 新增 Blog /// &lt;/summary&gt; /// &lt;param name="blogDto"&gt;Blog Dto&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; AddAsync(BlogDto blogDto) &#123; // Convert BlogDto to Blog var blog = this._mapper.Map&lt;Blog&gt;(blogDto); this._blogRepository.Add(blog); return await this._unitofwork.SaveChangeAsync(); &#125; /// &lt;summary&gt; /// 取得 Blog /// &lt;/summary&gt; /// &lt;param name="blogQueryDto"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;IEnumerable&lt;BlogDto&gt;&gt; GetAsync(BlogQueryDto blogQueryDto) &#123; var blogs = await this._blogRepository.GetAllAsync(); // Convert Blog to BlogDto var blogDtos = this._mapper.Map&lt;IEnumerable&lt;BlogDto&gt;&gt;(blogs); return blogDtos; &#125; /// &lt;summary&gt; /// 刪除 Blog /// &lt;/summary&gt; /// &lt;param name="blogId"&gt;Blog Id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; RemoveAsync(int blogId) &#123; var blog = await this._blogRepository.GetAsync(x =&gt; x.BlogId == blogId); this._blogRepository.Remove(blog); return await this._unitofwork.SaveChangeAsync(); &#125; /// &lt;summary&gt; /// 修改 Blog /// &lt;/summary&gt; /// &lt;param name="blogDto"&gt;Blog Dto&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; UpdateAsync(BlogDto blogDto) &#123; // Convert BlogDto to Blog var blog = this._mapper.Map&lt;Blog&gt;(blogDto); this._blogRepository.Update(blog); return await this._unitofwork.SaveChangeAsync(); &#125;&#125; Repository Pattern &amp; Unit Of Work (常見用法版) 程式碼範例 問題來了？在StudentService 中，StudentRepository 似乎變得有些多餘，因為它所做的，UnitOfWork 也都可以做，隨著項目的複雜，這樣就會造成很多的問題，比如： IUnitOfWork 的職責不明確。 Repository 的職責不明確。 Service 很困惑，因為它不知道該使用誰。 Service 的代碼越來越亂。 較好的使用方式 - 職責分離首先先調整 UnitOfWork 的介面與實作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 /// &lt;summary&gt; /// UnitOfWork 介面 /// &lt;/summary&gt; /// &lt;seealso cref="System.IDisposable" /&gt; public interface IUnitOfWork : IDisposable &#123; /// &lt;summary&gt; /// /// &lt;/summary&gt; IGenericRepository&lt;Blog&gt; BlogRepository &#123; get; &#125; /// &lt;summary&gt; /// DB Context /// &lt;/summary&gt; DbContext Context &#123; get; &#125; /// &lt;summary&gt; /// Saves the change. /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;int&gt; SaveChangeAsync(); &#125;&#125; /// &lt;summary&gt; /// UnitOfWork /// &lt;/summary&gt; public class UnitOfWork : IUnitOfWork &#123; /// &lt;summary&gt; /// /// &lt;/summary&gt; private bool disposed = false; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="UnitOfWork"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="context"&gt;The context.&lt;/param&gt; /// &lt;param name="blogRepository"&gt;The blog repository.&lt;/param&gt; public UnitOfWork( DbContext context, IGenericRepository&lt;Blog&gt; blogRepository) &#123; this.Context = context; this.BlogRepository = blogRepository; &#125; /// &lt;summary&gt; /// &lt;/summary&gt; public IGenericRepository&lt;Blog&gt; BlogRepository &#123; get; private set; &#125; /// &lt;summary&gt; /// Context /// &lt;/summary&gt; public DbContext Context &#123; get; private set; &#125; /// &lt;summary&gt; /// Dispose /// &lt;/summary&gt; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; /// &lt;summary&gt; /// SaveChange /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; SaveChangeAsync() &#123; return await this.Context.SaveChangesAsync(); &#125; /// &lt;summary&gt; /// Dispose /// &lt;/summary&gt; /// &lt;param name="disposing"&gt;&lt;/param&gt; protected virtual void Dispose(bool disposing) &#123; if (!this.disposed) &#123; if (disposing) &#123; this.Context.Dispose(); this.Context = null; &#125; &#125; this.disposed = true; &#125; &#125; 再來修改 Repository 的實作 123456789101112131415/// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;typeparam name="TEntity"&gt;The type of the entity.&lt;/typeparam&gt; /// &lt;seealso cref="Sample.Repository.Implement.GenericRepository&#123;TEntity&#125;" /&gt; public class BlogRepository&lt;TEntity&gt; : GenericRepository&lt;TEntity&gt; where TEntity : class &#123; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BlogRepository&#123;TEntity&#125;"/&gt; class. /// &lt;/summary&gt; /// &lt;param name="context"&gt;db context.&lt;/param&gt; public BlogRepository(DbContext context) : base(context) &#123; &#125; &#125; 再來是 Service 的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/// &lt;summary&gt;/// BlogService/// &lt;/summary&gt;public class BlogService : IBlogService&#123; private IMapper _mapper; private IUnitOfWork _unitofwork; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref="BlogService"/&gt; class. /// &lt;/summary&gt; public BlogService( IUnitOfWork unitofwork, IMapper mapper) &#123; this._unitofwork = unitofwork; this._mapper = mapper; &#125; /// &lt;summary&gt; /// 新增 Blog /// &lt;/summary&gt; /// &lt;param name="blogDto"&gt;Blog Dto&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; AddAsync(BlogDto blogDto) &#123; // Convert BlogDto to Blog var blog = this._mapper.Map&lt;Blog&gt;(blogDto); this._unitofwork.BlogRepository.Add(blog); return await this._unitofwork.SaveChangeAsync(); &#125; /// &lt;summary&gt; /// 取得 Blog /// &lt;/summary&gt; /// &lt;param name="blogQueryDto"&gt;查詢條件&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;IEnumerable&lt;BlogDto&gt;&gt; GetAsync(BlogQueryDto blogQueryDto) &#123; var blogs = await this._unitofwork.BlogRepository.GetAllAsync(); // Convert Blog to BlogDto var blogDtos = this._mapper.Map&lt;IEnumerable&lt;BlogDto&gt;&gt;(blogs); return blogDtos; &#125; /// &lt;summary&gt; /// 刪除 Blog /// &lt;/summary&gt; /// &lt;param name="blogId"&gt;Blog Id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; RemoveAsync(int blogId) &#123; var blog = await this._unitofwork.BlogRepository.GetAsync(x =&gt; x.BlogId == blogId); this._unitofwork.BlogRepository.Remove(blog); return await this._unitofwork.SaveChangeAsync(); &#125; /// &lt;summary&gt; /// 修改 Blog /// &lt;/summary&gt; /// &lt;param name="blogDto"&gt;Blog Dto&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;int&gt; UpdateAsync(BlogDto blogDto) &#123; // Convert BlogDto to Blog var blog = this._mapper.Map&lt;Blog&gt;(blogDto); this._unitofwork.BlogRepository.Update(blog); return await this._unitofwork.SaveChangeAsync(); &#125;&#125; 如此，是不是就明確許多。 整個專案的架構圖如下 Repository Pattern &amp; Unit Of Work (職責分離版) 程式碼範例 總結本篇完整介紹了 Repoistory 與 UnitOfWork 的應用範例，希望能幫助到大家。]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>C#</tag>
        <tag>Repository Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.Net Core DI 容器中 Service 生命週期]]></title>
    <url>%2F2019%2FASP-Net-Core-DI-%E5%AE%B9%E5%99%A8%E4%B8%AD-Service-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[使用 DI 的時候，註冊服務的生命週期是個很重要的議題，用的好，節省記憶體。提升程式效率，用不好，則可能造成重大的異常錯誤，本篇來簡單說明一下 ASP.NET Core 注入服務的三種生命週期。 Service 生命週期ASP.NET Core提供了一個內置的服務容器 IServiceProvider 負責管理服務的生命週期，從被依賴注入容器創建開始（就是將服務注入到你要使用的類的構造函數中），然後框架負責創建依賴關係的實例，並在不再需要時對其進行處理（就是說等我們調用完服務時，容器會自己去對注入的服務進行釋放）。 三種生命週期查看微軟程式碼，ServiceLifetime 有三種列舉值。 1234567// Microsoft.Extensions.DependencyInjection.ServiceLifetimepublic enum ServiceLifetime&#123; Singleton, Scoped, Transient&#125; Singleton 單一實例模式：單一實例對像對每個對象和每個請求都是相同的，不同客戶端不同請求都是相同的。 Transient 暫時性模式：暫時性對象，無論是不是同一個請求（同一個請求裡的不同服務）同一個客戶端，每次都是創建新的實例。 Scoped 作用域模式：作用域對像在一個客戶端請求中是相同的，但在多個客戶端請求中是不同的。 了解了生命周期的不同，要記得註冊服務時，要選擇適合的生命週期唷！]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>C#</tag>
        <tag>DI</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隨手 Design Pattern (3) - 簡單工廠模式 (Simple Factory Pattern)]]></title>
    <url>%2F2019%2F%E9%9A%A8%E6%89%8B-Design-Pattern-3-%E7%B0%A1%E5%96%AE%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F-Simple-Factory-Pattern%2F</url>
    <content type="text"><![CDATA[簡單工廠是相當易用的一種設計模式，當程式複雜度高的時候時候，可以利用此模式切割複雜度高的判斷式，抽離業務邏輯與建構式，讓業務邏輯單純，隔離複雜的建構式，有效提升程式碼的可讀性，藉由 C# 語法特性更可以降低程式複雜度。 定義簡單工廠模式(Simple Factory Pattern)：又稱為靜態工廠方法(Static Factory Method)模式，它屬於類創建型模式。 角色簡單工廠模式包含如下角色： Product：抽象產品角色抽象產品角色是所有產品的父類別，在 C# 來說可以是 抽象類別 (Abstract Class) 或者是 介面 (Interface)，公開屬性與方法簽章，外部程式依賴此角色。 ConcreteProduct：具體產品角色具體產生的產品實體，藉由工廠角色依據條件而建立。 Factory：工廠角色工廠角色負責建立對應的物件。 UML 類別圖 實作說明抽象產品角色 - 本次範例用 IBrid 介面來示範，公開 Name 屬性與 Fly 方法。 123456public interface IBird&#123; string Name &#123; get; set; &#125; void Fly();&#125; 具體產品角色 - Eagle &amp; Swan 兩種鳥類的具體實作 123456789public class Eagle : IBird&#123; public string Name &#123; get; set; &#125; = "老鷹"; public void Fly() &#123; // 實作可以飛高空 &#125;&#125; 123456789public class Swan : IBird&#123; public string Name &#123; get; set; &#125; = "天鵝"; public void Fly() &#123; // 實作只能飛低空 &#125;&#125; 工廠角色：使用 switch 實作 1234567891011121314151617public static class BirdFactory&#123; public static IBird GetBird(string birdName) &#123; switch (birdName) &#123; case "Swan": return new Swan(); case "Eagle": return new Eagle(); default: throw new Exception("missing matching bird name"); &#125; &#125;&#125; 12345678private static void Main(string[] args)&#123; var eagle = BirdFactory.GetBird("Eagle"); var swan = BirdFactory.GetBird("Swan"); Console.WriteLine($"Bird Name : &#123;eagle.Name&#125;"); Console.WriteLine($"Bird Name : &#123;swan.Name&#125;");&#125; 藉由 Bird Factory 將 switch 判斷式抽離，Main 程式複雜度下降，這也就是簡單工廠帶來的效益，專注商業邏輯，抽離複雜的判斷式。但是其實這仍不夠好，隨著實作 IBird 的鳥類越來越來多，BirdFactory 裡的 switch 會越來越複雜，也就越來越難維護。 這裡使用的是 CodeMaid 的 Spade 功能，有時間在另外做說明！ 這裡在提供一個使用 Linq 語法取代 switch 語法的範例，可以有效地降低複雜度。 123456789101112131415161718192021public static class BirdFactoryWithLinq&#123; private static readonly Dictionary&lt;string, IBird&gt; _birds; static BirdFactoryWithLinq() &#123; _birds = new Dictionary&lt;string, IBird&gt;(); _birds.Add("Eagle", new Eagle()); _birds.Add("Swan", new Swan()); &#125; private static IBird GetBird(string birdName) &#123; var bird = _birds .Where(x =&gt; x.Key.Equals(birdName)) .Select(x =&gt; x.Value) .FirstOrDefault(); return bird ?? throw new Exception("No match bird!"); &#125;&#125; GetBird 的複雜度由 4 降為 1，是不是很完美。 結論 優點 工廠封裝了各類別的建構式邏輯，客戶端不需要知道如何建構類別實體，可以直接操作公開的方法，做到實質的隔離，達成了職責分離。 透過參數設定檔，可以實現不修改成客戶端程式碼的，而增加可以使用類別。 缺點 使用簡單工廠模式將會增加系統中類別的數量，純理論來說增加了系統的複雜度和理解難度。 有可能造成工廠邏輯過於複雜，不利於系統的擴展和維護。 因使用靜態方法，所以工廠類別無法繼承。 總結優缺點，在情境式適合下，簡單工廠很容易的做到職責分離，搭配 C# Linq 更可以有效降低工廠的程式複雜度，是很值得使用的！ 參考範例Github 範例下載連結]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>C#</tag>
        <tag>Simple Factory Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隨手 Design Pattern (2) - 軟體分層設計模式 (Software Layered Architecture Pattern)]]></title>
    <url>%2F2019%2F%E9%9A%A8%E6%89%8B-Design-Pattern-2-%E8%BB%9F%E9%AB%94%E5%88%86%E5%B1%A4%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-Software-Layered-Architecture-Pattern%2F</url>
    <content type="text"><![CDATA[軟體分層設計模式是我這幾年專案必會使用的架構，它的效益在多人團隊分工上有極大的效益，且能有效專注修改區域，提高共用性，讓我們來看看這是怎樣的架構。 基本說明分層架構是運用最為廣泛的架構模式，幾乎每個軟體系統都需要通過層（Layer）來隔離不同的關注點（Concern Point），以此應對不同需求的變化，使得這種變化可以獨立進行；此外，分層架構模式還是隔離業務複雜度與技術複雜度的利器。 分層架構模式 展示層 (Presentation Layer)：接收外部請求( view、app、ap 等等 )，呼叫業務層，並將業務層回傳的 dto 轉成 viewmodel 回傳給外部。 業務層 (Business Layer)：接收展示層請求，專注處理商業邏輯，呼叫資料層，並將資料層回傳的 model 轉換成 dto 回傳給展示層。 資料層 (Data Layer)：專注處理資料，資料來源來自資料庫或其他其他服務，接收業務層呼叫，執行資料處理回傳 model。 共用層 (Common Layer)：將各層依賴的 entity、dto、enum 等放入此層，因共用層與其他層有參考關聯，此層物件務必力求簡單，且不可有商業邏輯。 受了 MRKT 大大的薰陶我習慣用以下方式命名 展示層 : Controller 業務層 : Service 資料層 : Repoitory 共用層 : Common 。 我的實作專案結構 Sla.Common Enum Dto Entity Sla.WebApi Parmeter ViewModel Sla.Service Interface Implement Sla.Repository Interface Implement Sla.Common共用層，跨層的 entity、dto、enum 放在此專案內 Sla.WebApi展示層 / Coontroller，以 .Net 來說，這裡通常是 MVC 專案 或 WebApi 專案，有接收的 Parameter 與 回傳 的 ViewModel 兩種類別。 Sla.Service商業邏輯層 / Service，商業邏輯放置於此，會定義服務介面並實作介面，讓展示層依賴介面而不是依賴實作。接收展示層的 參數 Dto 並回傳 實體 Dto Sla.Repository資料層 / Repository，資料存取放置於此，會定義資料層介面並實作介面，讓商業邏輯層依賴介面而不是依賴實作。接收商業邏層的 參數 Entity 並回傳 實體 Entity 心得當我是一個人開發的時候，分層設計真的感受不深，更多的是為何要弄得這麼複雜，但隨著工作團隊的擴展，多人合作開發的時候，分層設計就發揮出了它的價值，各個成員專注各自的層發開，不會被其他成員影響，當需要修改或擴充時，若是要改 UI，只需要異動展示層，若是新增商業邏輯則只需專注業務層，而是為要換第三方配合廠商或者更換資料庫，則只需專注在資料層去修改，而各層的物件又可以依不同情境做重用，不需重複開發，可謂好處多多。 效益整理如下 適合多人團隊分工時不互相影響 (一條龍開發時感受不深) 分層專注，可以專注修改，不會牽一髮動全身 但真的能達到這樣的效益，其實還有一些必要前提 物件設計須符合 SOLID 原則 各層依賴介面 (Interface)，不依賴實作 專案需導入 DI Framework，作到依賴注入，達成控制反轉 (IoC) 撰寫單元測試 (Unit Test) 保護每次修改 合理的設計各層職責物件，業務層更為重要 參考範例Github 範例下載連結]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>C#</tag>
        <tag>Software Layered Architecture Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隨手 Design Pattern (1) - 序篇]]></title>
    <url>%2F2019%2F%E9%9A%A8%E6%89%8B-Design-Pattern-1-%E5%BA%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[這個系列簡單紀錄我程式開發中用到的 Design Pattern，並附上範例說明應用情境，盡量用簡單的說明讓大家明瞭 Desin Pattern 預計會有以下項目： 軟體分層設計模式 (Software Layered Architecture Pattern) 簡單工廠模式 (Simple Factory Pattern) Respository 模式 (Respository Pattern) 雙重檢查鎖定模式 (Double-Checked Locking Pattern) 單例模式 (Singleton Pattern)]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoMapper.Extensions.Microsoft.DependencyInjection - AddAutoMapper 已過時]]></title>
    <url>%2F2019%2FAutoMapper-Extensions-Microsoft-DependencyInjection-AddAutoMapper-%E5%B7%B2%E9%81%8E%E6%99%82%2F</url>
    <content type="text"><![CDATA[AutoMapper.Extensions.Microsoft.DependencyInjection 簡單的讓 AutoMapper 註冊到 ASP.NET Core 中，但更版之後出現以 AddAutoMapper() 已過期的訊息，紀錄一下新版的用法。 舊版用法1services.AddAutoMapper(); AddAutoMapper() 會掃描所有 assembliy 然後做兩件事： 將實作 IProfile 的類別加入 mapping configuration 將 value resolvers, member value resolvers, type converters 加入 container 更新套件後出現1ServiceCollectionExtensions.AddAutoMapper(IServiceCollection)' is obsolete 原因新版本異動了參數簽章 改為傳入 assemblies 1services.AddAutoMapper(assembly1, assembly2 /*, ...*/); 或傳入 types 1services.AddAutoMapper(type1, type2 /*, ...*/); 解決方法 不怕麻煩的一個個傳入 改用以下寫法，仍然可以自動全部掃描 單一專案：傳入 Starup.cs1services.AddAutoMapper(typeof(Startup)); 多個專案參考：傳入 所有 Assemblies1services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); 參考連結https://github.com/AutoMapper/AutoMapper.Extensions.Microsoft.DependencyInjection/issues/105]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>AutoMapper</tag>
        <tag>C#</tag>
        <tag>Nuget Package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩玩樹莓派 - 序篇]]></title>
    <url>%2F2019%2F%E7%8E%A9%E7%8E%A9%E6%A8%B9%E6%A2%85%E6%B4%BE-%E5%BA%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[樹莓派是個微型電腦，藉由低成本高效能的硬體，讓更多人可以踏進電腦學習的世界，而至今，樹莓派上可以安裝很多種系統，做許多特定的事情，本文就是一系列的教學安裝心得。 預計有以下主題 智能家居：Hass.io 懷舊遊戲機：Retro Pie 懷舊遊戲機：Recalbox]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jeykll 快速安裝教學]]></title>
    <url>%2F2019%2FJeykll-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[Jeykll 是 Github 的聯合創始人的作品，以 Ruby 開發的靜態網頁產生器，是目前最受歡迎的，相關資源最多的 ssg，本篇就來簡單快速教學。 安裝先安裝 Ruby Windows 可以參考安裝 RudyInstaller for Windows 更新 Rudy Gems 1gem update --system 安裝 Jekyll 1gem install bundler jekyll 第一個站台1jekyll new jekylldemo 12cd jekylldemobundle exec jekyll serve 部署Github Pages 是和 Jekyll 最合拍的 Hosting 空間，同個一爸爸的優勢下，只要將整個原始檔案簽入 Github，過一會就會自動生成檔案。 結論優點 和 Github Pages 深度整合（其他 Hosting 空間也是很容易部署）。 相關插件資源眾多。 _config.yml 設定統一。 缺點 操作指令較少（搭配 rake 會好很多）。 產生靜態頁速度較慢。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hugo 快速安裝教學]]></title>
    <url>%2F2019%2FHugo-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[Hugo 是用 Go 語言開發的靜態網站產生器（Static Site Generator），有著超快產生速度的優點，就讓我們來玩玩看吧。 安裝Hugo 提供多種安裝方式，含括 Windows / Linux / macOS，以下列出 Windows 與 macOS 安裝方式，其他安裝方式請直接參考官網說明。 Chocolatey (Windows)1choco install hugo -confirm Homebrew (macOS)1brew install hugo 其他安裝方式請參考 install。 檢查安裝版本1hugo version 建立新站台1hugo new site hugodemo 新增佈景主題Hugo 安裝好是沒有佈景主題的，所以接下來必須來設定佈景主題。 相較於 Hugo，Hexo、Jekyll有預設佈景主題，這點是 Hugo 較為不便的地方。 下載佈景主題使用 git 下載，好處是新版本更新很方便。 123cd hugodemogit initgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 若沒有 git 的環境，可以直接下載 ananke theme 解壓縮放入 hugodemo/themes/ananke。 編輯 config.toml 並將主題設定為 Ananke1echo theme = "ananke" &gt;&gt; config.toml 其他佈景主題Hugo 也提供了很多佈景主題，請直接參考 Hugo Themes。 增加一個新文章1hugo new posts/my-first-post.md 啟動站台1hugo server -D 在瀏覽器中輸入紅框處網址即可看成果了。 Hugo 預設 port 為 1313，若被佔用會置換成其他 port。 目錄說明若展開 hugodemo 資料夾，會包含以下內容.├── archetypes│ └── default.md├── config.toml├── content├── data├── layouts├── static└── themes 其中 archetypes: 放置生成文件的基礎樣板資料夾。config.toml: 控制 hugo 產生網頁內容的設定檔，預設使用 toml 格式。（也支援 yaml 與 json 格式）。content: 放置 Markdown 文章與網頁內容的資料夾。data: 儲存一些 configuration 檔案的地方，協助建構靜態網頁。layouts: 儲存產生的網頁 layout 樣板（之後範例使用其他的 theme）。static: 放置靜態內容，如圖片，CSS 以及 *.js 等內容。themes: 從外部引入的 theme 檔案。 目前只要知道 config.toml, content, static 與 themes 這幾個部分即可。 站台設定打開 config.toml 1234baseURL = "https://example.org/"languageCode = "en-us"title = "My New Hugo Site"theme = "ananke" 部署當成功的執行站台後，產生的靜態檔會生成在 public 的資料夾下，將此資料夾的靜態檔部署到 Hosting 主機上。 各平台部署方式請參考官網說明。 結論優點 快！快！快！ 已整合眾多功能（分類、標籤、Sitemap、GA）。 config.toml 設定統一。 缺點 提供的佈景主題較少。 擴充插件較少。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩玩樹莓派 - RetroPie]]></title>
    <url>%2F2019%2F%E7%8E%A9%E7%8E%A9%E6%A8%B9%E8%8E%93%E6%B4%BE-RetroPie%2F</url>
    <content type="text"><![CDATA[Retro-Pie，復古的、樹梅派。RetroPie 是英國的一個開源專案，內建了許多經典遊戲的模擬器：GBA、N64、PSX 等等，而最近 Steam 官方釋出 Raspberry Pi 可以用的 Steam Link，RetroPie 也把它包進套件裡面。所以現在裝好 RetroPie 後，不只可以玩經典的神奇寶貝、牧場物語、馬力歐賽車，更可以玩 GTA V、Overcooked! 2。（當然前提你要有這些老遊戲的 ROM、也要有 Steam 遊戲） RetroPie 其實是基於 Raspbian 系統的一些套件，如果你已經有一台服役中的 Raspberry Pi，也可以直接安裝 RetroPie 的套件，不過還是建議跟著下面的步驟走，安裝預先做好的 RetroPie 映像檔（pre-build image），因為我已經幫你把一些雷踩過了。]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>Retro Pie</tag>
        <tag>懷舊遊戲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩玩樹莓派 - Hass.io]]></title>
    <url>%2F2019%2F%E7%8E%A9%E7%8E%A9%E6%A8%B9%E8%8E%93%E6%B4%BE-Hass-io%2F</url>
    <content type="text"><![CDATA[Hass.io 是 Home Assistant （簡稱 HA） 的 container 版本，HA 主流安裝有兩種方式, 是 Hassbian 與 Hassio; 但其實 HA 官方目前主推 Hass.io，優點是其有著友善的圖形介面、技術要求低, 對新手友善, 整體來說相對簡單，Hassio裡有類似 Plugin Store 的設計，擴充插件較為方便。 事前準備硬體 Raspberry Pi 3 model B+ 16G 以上的 micro SD 卡（官方建議 32G 以上） 5v 2.5A電源線（建議要足瓦） 軟體 Hass.io images Etcher 安裝燒進記憶卡開機安裝]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>Hass.io</tag>
        <tag>Home Assistant</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靜態網站產生器大比拚]]></title>
    <url>%2F2019%2FStatic-Site-Generator-Comparison%2F</url>
    <content type="text"><![CDATA[靜態網站產生器 (Static Site Generator) 是快速架站的利器，更是輕量級部落格架站的好幫手，本篇將常見的 Jekyll、Hexo、Hugo 三套工具做了評比‧。 選擇靜態網站的原因？現在有很多網站後端程式語言可供選擇，為什麼許多網站仍選擇靜態網站？ 不需要 Database。 不需要後端程式。 要速度快 靜態網站與動態網站相比更快，因為它們不需要後端處理或 Database 處理。 要安全性高 靜態網站比任何動態網站都更安全，因為安全漏洞更少。 Cache 靜態頁較容易且有效率。 JekyllJekyll是基於 Ruby Gem 的解析引擎，能夠將樣板、liquid 語言、markdown 轉換為”靜態網頁”的產生器。 Jekyll 優點 免費和開源。 簡單易用。 輕鬆地從熱門平台（例如WordPress）遷移內容。 Github Pages 支援。 自帶默認主題，安裝後即可使用。 眾多的插件。 完整的教學文件。 Jekyll 缺點 隨著網站內容的增長，構建過程變得非常慢。 很多插件都過時了。 HugoHugo 是一個用 Go 構建的靜態網站生成器。它被宣傳為“世界上最快的網站構建框架”。與Jekyll不同，Hugo是用Go編寫的，這是一種靜態編譯的語言。這在很多方面影響了 Hugo 的功能特別是插件。 可以在幾秒鐘內安裝Hugo，並在不到一秒的時間內構建一個平均靜態網站。 Hugo 優點 開源和免費。 超快的速度，引擎和速度優化。 Hugo 缺點 主題使用 Go 模板，需要熟悉 Go 來創建主題 Hugo 沒有附帶默認主題。 插件較少。 HexoHexo是基於 Node.js 的靜態網站生成器，Hexo 可以在幾秒鐘內生成數百個靜態文件。 優點 開源和免費。 自帶默認主題，安裝後即可使用。 速度快 Node.js 帶給您超級快的檔案產生速度，上百個檔案只需幾秒就能建立完成。 一鍵部署 強大的Markdown支持 Hexo 支援所有 GitHub Flavored Markdown 的功能，您甚至能在 Hexo 使用大部份的 Octopress 外掛。 豐富的外掛 Hexo 有強大的外掛系統，您可安裝外掛讓 Hexo 支援 Jade, CoffeeScript。 缺點 Hexo 有一個相對較大的社區，但大多數是非英語人士（來自中國） 錯綜複雜的 npm 生態 人氣大比拚 來源出處 結論最後選擇了 Hexo 作為 Blog 生成器，原因有幾個 中文資源多 插件功能齊全完整 node.js 較為熟悉 你，選擇哪個呢？]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
        <tag>Hugo</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB Sharding with Docker]]></title>
    <url>%2F2019%2FMongoDB-Sharding-with-Docker%2F</url>
    <content type="text"><![CDATA[sharding 為 MongoDB 所擁有的一種資料分散處理架構，簡單的說就是將資料分片 (shard) 儲存到不同的機器中，最常應用在大數據的案例上。在海量資料的儲存情境上，垂直擴充架構是無法滿足的，必須透過水平擴充來實現。 基本觀念基本角色MongoDB 的 sharding 有三種角色 shard：負責存放資料，3.6 版後須為 replica set 架構 config servers：負責記錄資料存在那些 shard 中，3.6 版後須為 replica set 架構 mongos：擔任 router 功能，接收 clitent application 的請求，向 config servers 查詢資料所在的 shard（會快取），然後去 shard 拿取資料 replica setMongoDB 服務器集群，用於實現 Relication 和 Automatic failover。 Relication 策略有兩種： one primary and two secondary一個 primary node + 二個 secondary node，優點是二份備份，適合需要資料高度安全的情境。 one primary, one secondary and one arbiter一個 primary node + 一個 secondary node + 一個 arbiter，arbiter 不存放資料，只負責 heartbeat，優點是節省資料保存空間，適合硬碟空間有限的情境。 動手實作container 規劃說明在 docker 環境下，快速建立起 mongodb sharding 架構規劃，在空間有限下我們用 3 台 mongos、3 台 config servers、2 個 shard（採用 one primary, one secondary and one arbiter，所以有 2 台 primary、2 台 secondary、2 台 arbiter 共 6 台） container 清單： shard：shard1-data1shard1-data2shard1-arbitershard2-data1shard2-data2shard2-arbiter config servers：config1config2config3 mongos：mongos1mongos2mongos3 產生 keyfile keyfile 適合在開發或測試環境中使用，正式環境建議使用 x.509 certificates 使用 keyfile 身份驗證，replica set 中的每個 mongod 都使用 keyfile 的內容作為共享密碼來驗證部署中的其他成員。只有具有正確 keyfile 的 mongod 才能加入 replica set。 在 UNIX 系統上，密鑰文件不得具有 group 或 world 權限。 在 Windows 系統上，不檢查密鑰文件權限。 12openssl rand -base64 756 &gt; &lt;path-to-keyfile&gt;chmod 400 &lt;path-to-keyfile&gt; 產生好的 keyfile 名稱為 路徑為 ```c:\data\mongo\```12345678910### 建立 volume```shdocker volume create mongo-shard1-data1docker volume create mongo-shard1-data2docker volume create mongo-shard1-arbdocker volume create mongo-shard2-data1docker volume create mongo-shard2-data2docker volume create mongo-shard2-arb 建立 shard1234567891011121314# 建立 shard1-data1docker run -v c:/data/mongo/mongo-keyfile:/data/mongo-keyfile --name shard1-data1 --net host --restart always -d -v c:/data/mongo/shard1-data1:/data/db mongo mongod --shardsvr --replSet shard1 --port 27018 --auth --keyFile /data/mongo-keyfile --bind_ip localhost# 建立 shard1-data2docker run -v c:/data/mongo/mongo-keyfile:/data/mongo-keyfile --name shard1-data2 --net host --restart always -d -v c:/data/mongo/shard1-data2:/data/db mongo mongod --shardsvr --replSet shard1 --port 27019 --auth --keyFile /data/mongo-keyfile --bind_ip localhost# 建立 shard1-arbiterdocker run -v c:/data/mongo/mongo-keyfile:/data/mongo-keyfile --name shard1-arbiter --net host --restart always -d -v c:/data/mongo/shard1-arbiter:/data/arbiter mongo /bin/bash -c " mkdir -p /data/arbiter | mongod --replSet shard1 --dbpath /data/arbiter --port 27020 --auth --keyFile /data/mongo-keyfile --bind_ip localhost"docker run -p 27018:27018 --name mongo-shard1-data1 --restart always -d -v mongo-shard1-data1:/data/db mongo mongod --shardsvr --replSet shard1 --port 27018 --bind_ip localhostdocker run -p 27019:27019 --name mongo-shard1-data2 --restart always -d -v mongo-shard1-data2:/data/db mongo mongod --shardsvr --replSet shard1 --port 27019 -- --bind_ip localhostdocker run -p 27020:27020 --name mongo-shard1-arb --restart always -d -v mongo-shard1-arb:/data/arb mongo /bin/bash -c " chmod 777 /data/arb | mongod --replSet shard1 --dbpath /data/arb --port 27020 --bind_ip localhost" mongos –configdb config-set/srvmongoDB3:47018,srvmongoDB2:47019,srvmongoDB1:47020 –bind_ip localhost,srvmongoDB3 –port 37018 –keyFile /data/mongo-keyfile 設定 shard1123456789101112131415161718192021222324252627282930313233343536373839docker exec -it mongo-shard1-data1 mongo localhost:27018use admindb.createUser( &#123; user: "admin", pwd: "admin", roles: [ &#123; role: "root", db: "admin" &#125; ] &#125;);config = &#123; "_id": "shard1", "members": [ &#123; _id:0,host:"localhost:27018" &#125;, &#123; _id:1,host:"localhost:27019" &#125;, &#123; _id:2, host:"localhost:27020", arbiterOnly:true &#125;] &#125;rs.initiate(config)rs.status()rs.initiate()rs.status();db.auth("admin","admin");rs.add("localhost:27019")rs.addArb("localhost:27020")rs.status(); 建立 config servers建立 mongos]]></content>
      <categories>
        <category>系統安裝</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 LINQ 處理分群情境]]></title>
    <url>%2F2018%2F%E7%94%A8%20LINQ%20%E8%99%95%E7%90%86%E5%88%86%E7%BE%A4%E6%83%85%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Language Integrated Query (LINQ) 是一組以直接將查詢功能整合至 C# 語言為基礎之技術的名稱。LINQ 最明顯的「語言整合」部分就是查詢運算式。 查詢運算式是以宣告式「查詢語法」撰寫。 透過使用查詢語法，您就可以利用最少的程式碼，針對資料來源執行篩選、排序及分組作業。(參考來源) LINQ的強大不是本文的重點，本文主要是示範如何簡潔的處理資料分群問題。 情境說明一組數量不固定的數字集合，想平均分配至30組中。 土法煉鋼法最簡單的方式可以用一個 for 迴圈快速解決，但這實在太不優雅了。 LINQ 解法LINQ 可以很優雅地解決這個問題。 1234567891011121314151617var ids = new List&lt;int&gt;() &#123; 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87, 21, 33, 45, 21, 784, 24, 55, 68, 87,&#125;;var result = ids.Select((value, index) =&gt; new &#123; PairNum = index % 30, value &#125;) .GroupBy(pair =&gt; pair.PairNum) .Select(grp =&gt; grp.Select(g =&gt; g.value).ToList()) .ToList();result.Dump(); 分群結果 範例程式Github範例]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>LINQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit 空資料夾]]></title>
    <url>%2F2018%2F%E5%9C%A8-Git-Commit-%E7%A9%BA%E8%B3%87%E6%96%99%E5%A4%BE%2F</url>
    <content type="text"><![CDATA[Git 基本只對檔案作版控，資料夾中若沒有檔案是無法 commit 的，若想要 commit 空資料夾才可採取下面兩種做法。 新增 .gitkeep / .keep 在目的空資料夾開啟 Git Bash，執行以下命令，產生空檔案 1touch .gitkeep 檔案名稱其實隨意都可，但 .gitkeep / .keep 較常見。 新增 .gitingore 在目的空資夾下新增一個 .gitingore 檔案並編輯如下 1234# 忽略所有文件*# 除了這個文件!.gitignore 我個人是比較喜歡第一種作法，讓 .gitingore 還是總控在根目錄下。]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（5）－Material 主題設定]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-5-Material-%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[自建 Blog 其中一種樂趣就是可以換很多種風格迥異的主題，不過仍需要一點程式基礎才能做好設定，接下來會以 Hexo 排名第二的主題 - Material 來做說明。 下載主題與更名設定檔Hexo 只需要將主題文件放置於站點目錄的 themes 目錄下。從 Github 下載最新版本。並更名為 material。 資料夾可任意更名，但 _config.yml 的設定需同資料夾名稱。 第一次啟用時需先將 material 內的 _config.template.yml 更名為 _config.yml。 如何變更主題先理解兩個名詞 站點配置文件 站點目錄下的 _config.yml 主題配置文件 material 資料夾下的 _config.yml 開啟站點配置文件，更改 language 與 theme 設定 語系支援清單 العَرَبِيَّة (ar) Deutsch (de) English (en) Español (es) Français (fr) 日本語 (ja) Malay (ms) Portuguese (Brazil) (pt-BR) 简体中文 (zh-CN) 繁體中文 (zh-TW) 1language: zh-TW 1theme: material 為什麼選擇 Material 真的很潮，Material Design 真的很潮，讓人印象深刻。 完整的文件說明，說明連結 整合眾多功能，整合了回覆留言、標籤、分類、時間軸、站內搜尋、 QR Code 等功能 Material 主題設定接下來主題配置文件的設定 設定樣式 Paradox: 標準 Material Design Isolation: 極簡風格 Nexus: 未完成，此專案已經久未更新，應該是沒有完成之日了。 1234# Schemesscheme: Paradox#scheme: Isolation#scheme: Nexus 選單設定 選單設定是比較有趣的地方，可以自由排列想要選單。 icon: 使用 Material icon，完整 icon 清單請參考 material design icons divider: 分隔線 12345678910111213141516171819202122232425262728293031323334353637383940414243# Sidebar Customizesidebar: dropdown: Email Me: link: mail@mail.com icon: email Github: link: "https://github.com/username" icon: layers homepage: use: true icon: home divider: false archives: use: true icon: inbox divider: false categories: use: true icon: chrome_reader_mode divider: false pages: 標籤: link: "/tags" icon: bookmark divider: false 時間軸: link: "/timeline" icon: timeline divider: false #About: #link: "/about" #icon: person #divider: false article_num: use: true divider: false footer: divider: true theme: true support: false feedback: false material: false 如此就一個看起來蠻完整的外觀囉。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
        <tag>Hexo Themes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo（4）－部署到 GitHub Pages]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-4-%E9%83%A8%E7%BD%B2%E5%88%B0-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[Hexo 產生的靜態網誌預設可以本機執行，但若要讓大家看看到勢必要部署到外部網路空間，由於是靜態網站部署到哪個網頁空間都不成問題，本文是建議部署到 GitHub Pages 上，以下就一步步說明步驟。 部署說明Hexo 預設可以支援以下部署方式 Git Heroku Rsync OpenShift FTPSync SFTP 手動 Copy public 資料夾 本文使用 Git 部署，需先安裝 hexo-deployer-git 套件 其他部署方式請參考 Hexo部署 1npm install hexo-deployer-git --save GitHub Pages 設定到 GitHub 上新增一個 repo，名稱必須是 {username}.github.io 設定 _config.yml1234deploy: type: git repo: https://&lt;username&gt;:&lt;password&gt;@github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master repo 有幾種驗證方式可以 push 到 Github，這裡選擇最簡單的自帶帳密的方式。 若有多組 Git 部署可以參考以下設定 12345deploy: type: git repo: github: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git,master gitcafe: https://gitcafe.com/&lt;username&gt;/&lt;username&gt;.git,gitcafe-pages 若是多種部署方式可參考以下設定 12345deployer:– type: git repo:– type: heroku repo: 開始部署請執行以下命令 1hexo d 也可使用以下兩種指定，產生網頁後部署 1hexo d -g 或 1hexo g -d 執行完之後就算完成部署到外部網頁空間囉。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 ASP.NET Core 中使用 AutoMapper]]></title>
    <url>%2F2018%2F%E5%9C%A8-ASP-NET-Core-%E4%B8%AD%E4%BD%BF%E7%94%A8-AutoMapper%2F</url>
    <content type="text"><![CDATA[AutoMapper 是一個類別對應轉換的套件，在ASP.NET Core專案中的用法有有點差異，本篇說明適合ASP.NET Core 的簡潔用法。 安裝套件1Install-Package AutoMapper.Extensions.Microsoft.DependencyInjection 此套件是使用 ASP.Net Core 自帶的 DI Framework，讓 AutoMapper 使用上更簡潔優雅，此套件依賴了 AutoMapper，會自動安裝。 加入 Startup.cs123456public void ConfigureServices(IServiceCollection services)&#123; // 加入 AutoMapper services.AddAutoMapper(); services.AddMvc();&#125; ASP.Net Core 專案中要使用什麼東西皆是相同套路，在 ConfigureServices 中 AddAutoMapper 這個 Middleware。 建立 Profile12345678public class UserProfie : Profile&#123; public UserProfie() &#123; // 建立 Profile 對照定義 CreateMap&lt;UserResultModel, UserViewModel&gt;(); &#125;&#125; Profile 的重點在繼承 Profile 這個類別 使用 IMapper1234567891011121314151617181920212223public class HomeController : Controller&#123; private IMapper _mapper; private IUserService _userService; public HomeController(IMapper mapper, IUserService userService) &#123; this._mapper = mapper; this._userService = userService; &#125; public IActionResult Index() &#123; // 取得 user var user = this._userService.Get(); // 將 user 置換成 ViewModel var userViewModel = _mapper.Map&lt;IEnumerable&lt;UserViewModel&gt;&gt;(user); ViewData["User"] = userViewModel; return View(); &#125;&#125; 只要透過建構式注入 IMapper，就可以透過 Map 這個方法 Mapper Profile 有定義到類別。 結論這樣的作法有什麼好處呢？ 夠簡潔。使用 AddAutoMapper 方法，啟動 AutoMapper middleware，簡單明瞭。 低耦合。藉由繼承 Profile ，AutoMapper 自動取得所有定義 Profile，並將 IMapper 注入到需要的區塊中，降低程式碼對 AutoMapper 的耦合度。 簡單的一句話，Asp.Net Core 真叫人愛不釋手。 參考範例 參考連結 Using Automapper In ASP.net Core AutoMapper Docs]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>AutoMapper</tag>
        <tag>C#</tag>
        <tag>Nuget Package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo（3）－基本設定]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-3-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[有了第一個自己的 Blog，也順利的產身第一篇文章，接下來我們來做一些設定，讓 Blog 更量身打造一些。 請打開目錄下的 _config.yaml ，我們一步步調整。 Site 設定Site 是 Blog 的基本資訊，請修改基本的資訊上去。 12345678# Sitetitle: Hexosubtitle:description:keywords:author: John Doelanguage:timezone: URL 設定123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://raychiutw.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: url：Blog 的網址。 root：若網站有子目錄記得修改。&#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; permalink：若有 SEO 考量，可改為更簡短的設定 Directory 設定123456789# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: 本區使用預設值即可 Extensions 設定1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape theme：主題設定預設 landscape，後續會改使用 material。 Deployment 設定1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 部署的方式會是部署到 Github Pages，這部分有後續有專文說明 結論Hexo 預設的定義並不複雜，但是要讓他更完善好用仍須費一番心思調整，接著就來一一說明。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core 無法使用 DeploymentItem 的替代方案]]></title>
    <url>%2F2018%2FASP-NET-Core-%E7%84%A1%E6%B3%95%E4%BD%BF%E7%94%A8-DeploymentItem-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在 MSTest 中，若要在執行測試時能調用實體檔案，通常會用 DeploymentItem Attribute 來指定要同時部署的檔案，但屬性在 ASP.NET Core 中不再支援，本篇說明其他替代方案。 好用的 DeploymentItem在寫測試時，我們常會用以下作法調用外部檔案。 1234567891011121314151617using System.IO;using Microsoft.VisualStudio.TestTools.UnitTesting;namespace DeploymentItem.Tests&#123; [TestClass] public class UnitTestWithDeploymentItem &#123; [TestMethod] [DeploymentItem("TestData\\Sample.csv")] public void TestMethod1() &#123; var file = new StreamReader("Sample.csv"); // test code ... &#125; &#125;&#125; 完整使用說明 但在 ASP.NET Core 專案中使用 DeploymentItem 不會報錯，但測試執行後會找不到檔案（因為實際上沒有作用）！ 解決方式其實沒有什麼替代方式，就是不要用了，在程式碼直接指定明確的路徑就好了。 12345678910111213141516using System.IO;using Microsoft.VisualStudio.TestTools.UnitTesting;namespace DeploymentItem.Tests&#123; [TestClass] public class UnitTest1 &#123; [TestMethod] public void TestMethod1() &#123; var file = new StreamReader("TestData\\Sample.csv"); // test code ... &#125; &#125;&#125; 結案～ 範例程式連結https://github.com/raychiutw/asp-net-core-deploymentitem]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>C#</tag>
        <tag>MSTest</tag>
        <tag>UnitTest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core 啟用 Web.config Transformation]]></title>
    <url>%2F2018%2FASP-NET-Core-%E5%95%9F%E7%94%A8-Web-config-Transformation%2F</url>
    <content type="text"><![CDATA[.Net Framework 4.0 提供了 Transformation 功能，讓 Web.Config 與 app.Config 可以依據組態設定建置不同的參數，這項好用的功能在 .Net Core 的專案中已無法作用，本文紀錄如何再次啟用這好用的功能。 情境說明ASP.NET Core 2.0 是靠 application.json 來取代 web.config，但有時候我們仍需要在 web.config 作一些環境參數切換，甚至有些第三方套件仍是倚賴 XML 做設定 (ex: Nlog.xml)，以下步驟將說明如何讓 ASP.NET Core 2.0 重新啟用 Transformation 環境說明 Visual Studio 2017 ASP.Net Core 2.0 加入 web.config 設定ASP.Net Core 範本專案沒有 web.config, 我們先手動新增並輸入以下設定。 1234567&lt;system.webServer&gt; &lt;aspNetCore processPath="%LAUNCHER_PATH%" arguments="%LAUNCHER_ARGS%" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout"&gt; &lt;environmentVariables&gt; &lt;environmentVariable name="ASPNETCORE_ENVIRONMENT" value="Development" /&gt; &lt;/environmentVariables&gt; &lt;/aspNetCore&gt;&lt;/system.webServer&gt; 再新增 web.release.config 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration xmlns:xdt="http://schemas.microsoft.com/XML-Document-Transform"&gt; &lt;system.webServer&gt; &lt;aspNetCore&gt; &lt;environmentVariables&gt; &lt;environmentVariable name="ASPNETCORE_ENVIRONMENT" xdt:Transform="Remove" xdt:Locator="Match(name)" /&gt; &lt;/environmentVariables&gt; &lt;/aspNetCore&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 在 web.config 中指定了環境變數為 Development，而 web.release.config 則在 release 組態建置時 將其移除，如此便達成了 Debug 組態時專案使用 application.development.json，Realese 組態使用 applictaion.json。 編輯 csproj接下來我們直接編輯 csproj，加入以下設定。 1234&lt;ItemGroup&gt; &lt;DotNetCliToolReference Include="Microsoft.DotNet.Xdt.Tools" Version="2.0.0" /&gt; ... 其他套件參考 ...&lt;/ItemGroup&gt; 請直接編輯 csproj，請勿使用 Nuget Manager 安裝。 在 &lt;/project&gt; 之前請輸入以下設定 12345678910&lt;Target Name="ApplyXdtConfigTransform" BeforeTargets="_TransformWebConfig"&gt; &lt;PropertyGroup&gt; &lt;_SourceWebConfig&gt;$(MSBuildThisFileDirectory)Web.config&lt;/_SourceWebConfig&gt; &lt;_XdtTransform&gt;$(MSBuildThisFileDirectory)Web.$(Configuration).config&lt;/_XdtTransform&gt; &lt;_TargetWebConfig&gt;$(PublishDir)Web.config&lt;/_TargetWebConfig&gt; &lt;/PropertyGroup&gt; &lt;Exec Command="dotnet transform-xdt --xml &amp;quot;$(_SourceWebConfig)&amp;quot; --transform &amp;quot;$(_XdtTransform)&amp;quot; --output &amp;quot;$(_TargetWebConfig)&amp;quot;" Condition="Exists('$(_XdtTransform)')" /&gt;&lt;/Target&gt; 主要的執行主體在 &lt;Exec /&gt; 區段，執行的時機設定在 BeforeTargets=&quot;_TransformWebConfig&quot; 完整參數說明如下 12345678.NET Core XML Document TransformationUsage: dotnet transform-xdt [options]Options: -?|-h|--help Show help information --xml|-x The path to the XML file to transform --transform|-t The path to the XDT transform file to apply --output|-o The path where the output (transformed) file will be written --verbose|-v Print verbose messages 發行專案接下來就來測試吧，發行 Debug 組態 與 Release 組態各建置一次， web.config 應如下方有正確的切換了。 Debug 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;!-- To customize the asp.net core module uncomment and edit the following section. For more info see https://go.microsoft.com/fwlink/?linkid=838655 --&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" resourceType="Unspecified" /&gt; &lt;/handlers&gt; &lt;aspNetCore processPath="dotnet" arguments=".\Transformation.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout"&gt; &lt;environmentVariables&gt; &lt;environmentVariable name="ASPNETCORE_ENVIRONMENT" value="Development" /&gt; &lt;/environmentVariables&gt; &lt;/aspNetCore&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;&lt;!--ProjectGuid: f0574043-a304-4eec-9e63-e3ef5d3184cd--&gt; Release 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;!-- To customize the asp.net core module uncomment and edit the following section. For more info see https://go.microsoft.com/fwlink/?linkid=838655 --&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" resourceType="Unspecified" /&gt; &lt;/handlers&gt; &lt;aspNetCore processPath="dotnet" arguments=".\Transformation.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout"&gt; &lt;environmentVariables&gt;&lt;/environmentVariables&gt; &lt;/aspNetCore&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;&lt;!--ProjectGuid: f0574043-a304-4eec-9e63-e3ef5d3184cd--&gt; 結論與補充 若是 ASP.NET Core 1.x 請參考 點我 範例只示範了 remove ，相關 XDT 語法請參考 MDSN XDT Reference 不同的 XML 皆可以用類似的設定做 Transformation 程式碼範例sample code 參考資料https://github.com/nil4/dotnet-transform-xdt]]></content>
      <categories>
        <category>程式開發</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>Transformation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（0）－目錄]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-0-%E7%9B%AE%E9%8C%84%2F</url>
    <content type="text"><![CDATA[Hexo 是一個使用 Node.js 為基礎的靜態網站產生器。使用 Markdown 解析文章，透過主題產生靜態檔案。而且他是由台灣人所開發出來的。 優點 台灣人開發，中文資源豐富。 Node.js 生態完整，插件完整。 頁面產生速度快。 缺點 Node.js 插件眾多，依賴複雜，有可能會踩坑。 Hexo _config.yaml 與 Hexo Theme _config.yaml 交互設定較複雜。 系列文章連結 Hexo教學（1）－快速安裝 Hexo教學（2）－建立第一篇文章 Hexo教學（3）－基本設定 Hexo教學（4）－部署到 GitHub Pages Hexo教學（5）－Material 主題設定 Hexo教學（6）－Material 程式碼高亮 Hexo教學（7）－Material 整合功能 Hexo教學（8）－Material RSS QRCode 站內搜尋 Hexo教學（9）－Sitemap.xml 與 robot.txt]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（2）－第一篇文章]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-2-%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[快速建立第一個 Bolg 之後，接下當然是來產生第一篇文章。 用指令產生文章Hexo new “文章名稱” 可以快速產生一個 markdown 出來，產生的檔案放在 /source/post/ 下。 1npm new first-post 產生靜態檔還記得上篇說提，Hexo 是將 markdown 產生靜態 html 的框架，有了 markdown 後，那就讓我們來產生靜態檔吧。 1hexo generate 或者 1hexo g 檢查 /public/ 下是否有剛剛那篇的 html 了呢？ 讓我們再去看看 http://localhost:4000 是否有新文章了。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教學（1）－快速安裝]]></title>
    <url>%2F2018%2FHexo%E6%95%99%E5%AD%B8-1-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%2F</url>
    <content type="text"><![CDATA[那我們就開始吧。 安裝 Node.js下載Node.js 安裝 Hexo1npm install -g hexo-cli 建立第一個 Blog請在想要的目錄下打開命令列視窗。 123hexo init myblogcd myblognpm install 執行站台1hexo server 或者 1hexo s 在瀏覽器輸入 http://localhost:4000 有看到下圖就成功建立第一個部落格站囉。 。]]></content>
      <categories>
        <category>應用程式</category>
      </categories>
      <tags>
        <tag>Static Site Generator</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[開張大吉]]></title>
    <url>%2F2018%2F%E9%96%8B%E5%BC%B5%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[為什麼想寫部落格？ 為什麼到這把年紀才想寫部落格？ 其實！就是因為這把年紀阿！！ 最近我的老闆突然問我：Ray！你的代表作是什麼？ 我瞬間卡彈無法回答 這些年我也累積了不少東西但是我卻回答不出來，真的是年紀大了，看來得靠一些文字來記錄了． 於是乎寫部落格的想法就這樣油然而生了！ 稍微查了一下主要分為兩種方式 使用BSP（痞客邦，Blogger等等） 自建網站 （WordPress） 使用 BSP 是最省事的，但一旦業者不玩了，備份文章或搬家這真的是一場災難，而我只想保留我的心得，並未肖想成為部落客，能夠好好的保存資料才是最重要的．自建網站符合我的目的，但入門門檻實在不低，網路空間，網域，還有非我擅長的WordPress． 後來找到了 GitHub Pages，可以免費的使用，但只限定靜態頁面，原生支持 Jekyll （將 Markdown 生成靜態網頁的開源服務），試用了一陣子發現有些想要的功能要自行在安裝出來實在不容易． 最後找到了 Hexo，一套類似 Jekyll 但基於 Node.js 運行的軟體，經過幾天的安裝設定，把想要的樣式與功能都做好，成為目前部落格的樣子．接下來會把使用上的心得寫出來，總之 萬事起頭難，而我開始了！]]></content>
      <categories>
        <category>雜記</category>
      </categories>
  </entry>
</search>
